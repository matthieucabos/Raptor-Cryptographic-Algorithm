%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Crypto\sphinxhyphen{}Doc}
\date{Oct 22, 2021}
\release{1.0}
\author{CABOS Matthieu}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Numeric Base Recursive Builder Algorithm}
\label{\detokenize{base_opt_parallel:numeric-base-recursive-builder-algorithm}}\label{\detokenize{base_opt_parallel::doc}}
\newpage
\section{Numeric Base Recursive Builder Algorithm}
\label{\detokenize{Numeric_base_recursive_builder_algorithm:numeric-base-recursive-builder-algorithm}}\label{\detokenize{Numeric_base_recursive_builder_algorithm::doc}}
\sphinxAtStartPar
\sphinxstylestrong{This is the Main Base Builder Recursive Generator Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Numeric_base_recursive_builder_algorithm:algorithm}}
\sphinxAtStartPar
This is the main Base Table Builder Algorithm.
The algorithm is ruled by these following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Init time} : I init Time variable using the time library from Python

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{First Step Base Table} : This is the first step of the builder, I build the basic table from the tablebase function

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{First level of recursivity} : I build the first level of recursivity in safe mode using recursive\_build function

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Full Recursive algorithm} : We get the full computation of the table via the recursive\_build\_sup\_lvl method.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time calculation} : Computation of necessary time for the construction of the full array

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list of list} : A list of list containing all the string values representing the full generateed Base Table array

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Numeric_base_recursive_builder_algorithm:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{table}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rec\PYGZus{}level\PYGZus{}h} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}
        \PYG{n}{rec\PYGZus{}level\PYGZus{}m} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
        \PYG{n}{rec\PYGZus{}level\PYGZus{}l} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
        \PYG{n}{table} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{bases} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp}   \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{ok}    \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{mini}   \PYG{o}{=}\PYG{l+m+mi}{11}
        \PYG{n}{mytime} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{fini} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{finalt} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{initt}  \PYG{o}{=}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Construction algorithm using recursivity to build the nearest max\PYGZus{}int bound tables (never equal 4 000 000 000...)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n}{mini}\PYG{p}{,}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{ind} \PYG{o}{=} \PYG{l+m+mi}{1}
                \PYG{n}{ok}  \PYG{o}{=} \PYG{l+m+mi}{0}
                \PYG{n}{bases}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tablebase}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{table}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{recursive\PYGZus{}build}\PYG{p}{(}\PYG{n}{bases}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mini}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{while}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{ok}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{recursive\PYGZus{}build\PYGZus{}sup\PYGZus{}lvl}\PYG{p}{(}\PYG{n}{bases}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mini}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mini}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ind}\PYG{p}{)}
                        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mini}\PYG{p}{]}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                        \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{==}\PYG{n}{rec\PYGZus{}level\PYGZus{}l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{mini}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{ok}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{return} \PYG{n}{table}
\end{sphinxVerbatim}

\newpage
\section{tablebase}
\label{\detokenize{tablebase:tablebase}}\label{\detokenize{tablebase::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{tablebase}\PYG{p}{(}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tablebase:algorithm}}
\sphinxAtStartPar
This method allow to build the first step Numeric Base Transposition Table.
I use the Horner’s scheme procedure to build the correct table independantly of the base index.
I can build Base from 1\sphinxhyphen{}\textgreater{}a to 1\sphinxhyphen{}\textgreater{}z, mean Base11 to Base36.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base index to build
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The builded first step base table.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tablebase:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{letter} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{letterbis} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{o+ow}{and} \PYG{n}{base} \PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{10} \PYG{o+ow}{and} \PYG{n}{base} \PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10} \PYG{o+ow}{and} \PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}
                \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{recursive\_build}
\label{\detokenize{recursive_build:recursive-build}}\label{\detokenize{recursive_build::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recursive\PYGZus{}build}\PYG{p}{(}\PYG{n}{table\PYGZus{}base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{recursive_build:algorithm}}
\sphinxAtStartPar
This function recursively build a full Base Table from an existing one.
You can pass the first step table as already builded recursive table.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table\_base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
Base Table array as list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The recursively builded Base Table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{recursive_build:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{table\PYGZus{}base}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n}{table\PYGZus{}base}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{recursive\_build\_sup\_lvl\_safe\_mode}
\label{\detokenize{recursive_build_sup_lvl_safe_mode:recursive-build-sup-lvl-safe-mode}}\label{\detokenize{recursive_build_sup_lvl_safe_mode::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recursive\PYGZus{}build\PYGZus{}sup\PYGZus{}lvl\PYGZus{}safe\PYGZus{}mode}\PYG{p}{(}\PYG{n}{current}\PYG{p}{,}\PYG{n}{indice}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{recursive_build_sup_lvl_safe_mode:algorithm}}
\sphinxAtStartPar
The variable indeice correspond to the pow index of the current recursive build.
The current argument contain the current Base Tale array as list.
Using once again the Horner’s scheme, we can build each sup level without be limited by internal constraints.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The current table to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{indice}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The pow indice
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : A list containing the next level builded Base Table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{recursive_build_sup_lvl_safe_mode:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{current}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{indice}\PYG{p}{)}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{recursive\_build\_sup\_lvl}
\label{\detokenize{recursive_build_sup_lvl:recursive-build-sup-lvl}}\label{\detokenize{recursive_build_sup_lvl::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{recursive\PYGZus{}build\PYGZus{}sup\PYGZus{}lvl}\PYG{p}{(}\PYG{n}{table\PYGZus{}base}\PYG{p}{,}\PYG{n}{current}\PYG{p}{,}\PYG{n}{lvl}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{recursive_build_sup_lvl:algorithm}}
\sphinxAtStartPar
The recursive\_build\_sup\_lvl method is used to manage recursivity of the algorithm.
I mean i have wrote the iterative version of the recursive function. So you can easely use it and control it.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table\_base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
my first step Base table array as list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
my current Base table array as list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{lvl}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the level of recursivity
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{(list,int) Tuple} : The (Base Table builded, Index of depth) Couple of informations.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{recursive_build_sup_lvl:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{break\PYGZus{}ind} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{table\PYGZus{}base}\PYG{p}{:}
        \PYG{k}{try} \PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n}{recursive\PYGZus{}build\PYGZus{}sup\PYGZus{}lvl\PYGZus{}safe\PYGZus{}mode}\PYG{p}{(}\PYG{n}{current}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{except}\PYG{p}{:}
                \PYG{n}{break\PYGZus{}ind}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{k}{break}
\PYG{k}{return} \PYG{p}{(}\PYG{n}{res}\PYG{p}{,}\PYG{n}{break\PYGZus{}ind}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Algorithm v1}
\label{\detokenize{basetestrecursivev2:raptor-cryptographic-algorithm-v1}}\label{\detokenize{basetestrecursivev2::doc}}
\newpage
\section{Description of Crypter}
\label{\detokenize{Description of Crypterv1:description-of-crypter}}\label{\detokenize{Description of Crypterv1::doc}}
\sphinxAtStartPar
Welcom to Raptor cryptographic help

\sphinxAtStartPar
This following instructions give you the full light on the given cryptographic algorithm “Raptor”.
In a firts time I will explain the main algorithm rules. Each of the function used can be found on the
full source code and have a dedicated help section.

\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of Crypterv1:algorithm}}
\sphinxAtStartPar
This is the main algorithm of the program.
It allows from a system argv string to crypt it and get a string,key couple as result.
We will use this following variables to make it work :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : A list of list containing all the necessary Base table from Base 11 to Base 37

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : 2 as default, it means the minimum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} :  37 as default, it means the maximum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{chaine} : The string chain to crypt as system argv argument

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{choice} : A choice variable to manage the main loop (continue or quit)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Range} : Define the range of values generate into the corresponding Numeric Base a the begining

\end{itemize}
\begin{description}
\item[{The return of the algorithm is ruled by the fllowing variables:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The final half key as key

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The final crypted strin as string.

\end{itemize}

\item[{The alorithm is ruled by the following steps :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Generating the first step Base table for each necessary numeric base via the function table and splitTable

\item {} \begin{description}
\item[{Recursive build of the full Base table since the first step table using functions :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
rec\_table\_construct\_lvl1 : It draw the ‘zero theorem’ of Table construction since the first step. Must be considered as te first loop of recursive builder algorithm

\item {} 
\sphinxAtStartPar
rec\_manage : It draw the full Base Table using recursive loop

\end{itemize}

\end{description}

\item {} 
\sphinxAtStartPar
Instanciation of the local varables to manipulate the algorithm

\item {} 
\sphinxAtStartPar
I crypt the string using the crypt\_procedure function. The return is a couple (crypt text / key) wich allow to decrypt it.

\item {} \begin{description}
\item[{The crypt\_final method allow us to organise the crypt list into interpretables results. We store results in variables:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : Contains the raw crypted text as string

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : Contains the half key as str(int)

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\sphinxAtStartPar
This algorithm is stable in his domain and must be used on it.
Please not to try bigger data slice and automate it via shell script if necessary.
It should be used as a data crypter using a top level slicer and manager (from the shell script as exemple).

\sphinxAtStartPar
See source below to more explanation.


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of Crypterv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{choice}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{try} \PYG{p}{:} \PYG{n}{chaine}\PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{except} \PYG{p}{:} \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}
\PYG{n}{testc}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{res} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{29} \PYG{o+ow}{or} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{chaine}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer une chaine \PYGZlt{}29 : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{n}{testc} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{testk} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Clé unique : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{testk}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine décryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{clean\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}crypter}
\label{\detokenize{DescriptionofDecrypterv1:description-of-de-crypter}}\label{\detokenize{DescriptionofDecrypterv1::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofDecrypterv1:algorithm}}
\sphinxAtStartPar
This is the main solver algorithm program.
It allow us to decrypt datas slices crypted with the version 1 of the Raptor Cryptographic Algorithm.
To solve I need thse following variables :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{chaine} : The input crypted string storage

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : The minimum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} : The maximum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : The list of list containing the Base Table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{finalkey} : The key of the algorithm, the decrypting process absolutely need this key.

\end{itemize}

\sphinxAtStartPar
The solving procedure is ruled by the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generating the Base Table} and store it into my table2 variable

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting inputs} known as crypted string and his associated key.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decrypting process} using the decrypt\_procedure method (see documentation)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store and return} the results of decrypting process

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofDecrypterv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}  \PYG{o}{=} \PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}

\PYG{n}{finalke}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{finalke}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
        \PYG{n}{finalkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{decrypt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{chaine}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer la chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{finalkey}\PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez saisir la clé : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{finalke} \PYG{o}{=} \PYG{n}{miam}\PYG{p}{(}\PYG{n}{finalkey}\PYG{p}{)}
        \PYG{n}{decrypt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{finalke}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine decryptée : }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{decrypt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter ?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{reverse}
\label{\detokenize{reversev1:reverse}}\label{\detokenize{reversev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{reversev1:algorithm}}
\sphinxAtStartPar
A function to reverse a string as argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameter}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{s}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The string to reverse
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The reversed string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{reversev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{:}
        \PYG{n+nb}{str}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{n+nb}{str}
\PYG{k}{return} \PYG{n+nb}{str}
\end{sphinxVerbatim}

\newpage
\section{splitTable}
\label{\detokenize{splitTablev1:splittable}}\label{\detokenize{splitTablev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{splitTable}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitTablev1:algorithm}}
\sphinxAtStartPar
Split a string as array from the given separator.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The list to split
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The splitted list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitTablev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local\PYGZus{}list}\PYG{o}{=}\PYG{n}{table}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res\PYGZus{}list}
\end{sphinxVerbatim}

\newpage
\section{table}
\label{\detokenize{tablev1:table}}\label{\detokenize{tablev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{table}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{n}{debut}\PYG{p}{,}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{inc}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tablev1:algorithm}}
\sphinxAtStartPar
Base table recursive builder.
The generated Base table array is defined via :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{base} : Define the base to begin the table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{debut} : Define the first value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fin} : Define the last value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{inc} : Define the incrementation step

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first base of the table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{debut}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{fin}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The last value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{inc}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The value of incrementation step
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Str} : A string containing all the base generated representing the array (see conversion later)

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tablev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{powIndex}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{fin}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fin}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{debut}\PYG{p}{,}\PYG{n}{fin}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{current}\PYG{o}{=}\PYG{n}{i}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{count}\PYG{o}{=}\PYG{n}{powIndex}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{powIndex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                        \PYG{k}{else}\PYG{p}{:}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                                        \PYG{k}{else}\PYG{p}{:}
                                                \PYG{n}{count}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{l+m+mi}{1}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
                        \PYG{n}{current}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{p}{)}
                \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{reverse}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{return} \PYG{n}{represent}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_lvl1}
\label{\detokenize{rec_table_construct_lvl1v1:rec-table-construct-lvl1}}\label{\detokenize{rec_table_construct_lvl1v1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{powindex}\PYG{p}{,}\PYG{n}{last}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construct_lvl1v1:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm permit to edit much larger array from existing original base table.
Ths algorithm must be used as the init loop of the final recursive method (see rec\_manage method)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base table array
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current numeric base as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{powindex}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The pow index as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{last}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The Recursively builded Base table as list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construct_lvl1v1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lettrebase}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{powindex} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{del} \PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{i}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{powindex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{lettrebase}\PYG{p}{[}\PYG{n}{powindex}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_final}
\label{\detokenize{rec_table_construc_finalv1:rec-table-construct-final}}\label{\detokenize{rec_table_construc_finalv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{lvl}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construc_finalv1:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm manage array building since 2 levels of recursive construction.
=\textgreater{} Do not use for the first recursive building loop


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The first recursive level builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base to treat as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{lvl}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The level of recursivity in construction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully specified level recursivity builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construc_finalv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{basetable}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{basetable}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{eat} \PYG{o+ow}{in} \PYG{n}{basetable}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{table}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{eat}\PYG{o}{+}\PYG{n}{this}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_manage}
\label{\detokenize{rec_managev1:rec-manage}}\label{\detokenize{rec_managev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_managev1:algorithm}}
\sphinxAtStartPar
A recursivity manager to build properly the base table.
It must be used to map the numeric values into base values.
This method allow contruction of hundreds of thousand values table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The initial Base table to complete
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_managev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{table}
\end{sphinxVerbatim}

\newpage
\section{ascii\_to\_int}
\label{\detokenize{ascii_to_intv1:ascii-to-int}}\label{\detokenize{ascii_to_intv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{ascii_to_intv1:algorithm}}
\sphinxAtStartPar
Utils method : ascii to integer converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The string to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : A list containing all integers values since ASCII.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{ascii_to_intv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{letter} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{int\_to\_ascii}
\label{\detokenize{int_to_asciiv1:int-to-ascii}}\label{\detokenize{int_to_asciiv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{int_to_asciiv1:algorithm}}
\sphinxAtStartPar
Utils method : integer to ascii converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Description}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The int list to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The converted ASCII string since int list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{int_to_asciiv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cryptChaine}
\label{\detokenize{cryptChainev1:cryptchaine}}\label{\detokenize{cryptChainev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cryptChaine}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cryptChainev1:algorithm}}
\sphinxAtStartPar
The simple method to crypt an ascii string as integer list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The converted int list since an ascii string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all fully builded Base Table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list}  : A string list containing all the base crypted values, Must be used as a crypted list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cryptChainev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{local\_table\_dico}
\label{\detokenize{local_table_dicov1:local-table-dico}}\label{\detokenize{local_table_dicov1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{local\PYGZus{}table\PYGZus{}dico}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{local_table_dicov1:algorithm}}
\sphinxAtStartPar
Utils method : A method to convert a Base table to Python dictionnary


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table2}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all the fully builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{rangeB}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the max step of incrementation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Dictionnary} : A dictionnary representing the specified Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{local_table_dicov1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{str\PYGZus{}base}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{rangeB}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rangeB}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}base}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{str\PYGZus{}base}
\end{sphinxVerbatim}

\newpage
\section{limit\_range}
\label{\detokenize{limit_rangev1:limit-range}}\label{\detokenize{limit_rangev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{limit\PYGZus{}range}\PYG{p}{(}\PYG{n}{Range}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{limit_rangev1:algorithm}}
\sphinxAtStartPar
Utils method : A method to limit the Base range


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Range}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The range as a limit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The limited by range res.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{limit_rangev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{Range}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{Range}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}
\newpage
\section{base\_key}
\label{\detokenize{base_keyv1:base-key}}\label{\detokenize{base_keyv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{base_keyv1:algorithm}}
\sphinxAtStartPar
This is the key builder.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The base index list as a starting builder for key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : the builded key from index base list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{base_keyv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{36}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{10}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_poids}
\label{\detokenize{vec_poidsv1:vec-poids}}\label{\detokenize{vec_poidsv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_poidsv1:algorithm}}
\sphinxAtStartPar
Compute the vectorial cumulated weight of the list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The integer list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed accumulated weigth integer list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_poidsv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_1\_poids}
\label{\detokenize{vec_1_poidsv1:vec-1-poids}}\label{\detokenize{vec_1_poidsv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}1\PYGZus{}poids}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_1_poidsv1:algorithm}}
\sphinxAtStartPar
Compute the inverse of the vectorial cumulated weigth computation.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{vec\_poids}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The weigth as an integer list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed list containing the inverse operation of vec\_poids method

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_1_poidsv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{equa\_2\_nd}
\label{\detokenize{equa_2_ndv1:equa-2-nd}}\label{\detokenize{equa_2_ndv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{equa_2_ndv1:algorithm}}
\sphinxAtStartPar
Utils : An 2nd order equation solver


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The a coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The b coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{c}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The c coefficient
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float} : The solved equation positive root

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{equa_2_ndv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{racine1} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{racine2} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{delta} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{delta}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{racine1} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
        \PYG{n}{racine2} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{racine1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine1}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine2}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{multlist}
\label{\detokenize{multlistv1:multlist}}\label{\detokenize{multlistv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multlist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{multlistv1:algorithm}}
\sphinxAtStartPar
Utils : A point by point list multiplier


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float list} : The computed point by point multiplication

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{multlistv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{transpose\_base}
\label{\detokenize{transpose_basev1:transpose-base}}\label{\detokenize{transpose_basev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{transpose_basev1:algorithm}}
\sphinxAtStartPar
A method to transpose an integer list to the corresponding key’s base index
=\textgreater{} The result will be a succession of transposed values from differents integers to differents base


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The integer converted since ASCII list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The full Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list}: The crypted list as String list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{transpose_basev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else} \PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{inv\_transpose\_base}
\label{\detokenize{inv_transpose_basev1:inv-transpose-base}}\label{\detokenize{inv_transpose_basev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{inv_transpose_basev1:algorithm}}
\sphinxAtStartPar
The inverse method to decrypt a str list of base transposed values


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The crypted list as String list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The full Base table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The decrypted list as integers

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{inv_transpose_basev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_procedure}
\label{\detokenize{crypt_procedurev1:crypt-procedure}}\label{\detokenize{crypt_procedurev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_procedurev1:algorithm}}
\sphinxAtStartPar
The crypter manager to orchestrate the crypting procedure.
It works from these steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We convert the given ascii string as integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the Base index list as key from the converted integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We build the second part of the key since the mirror of the Base index list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the cumulated weight of the integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the point by point multiplication between cumulated weigth list and original integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We transpose the multiplied list into the given specified Base from the key}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We associate the crypted strin to the key as return}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The string to crypt
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list tuple} : The couple crypted string and key as result. It permits to decrypt any message.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_procedurev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{int\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{n}{base\PYGZus{}keyy}  \PYG{o}{=} \PYG{n}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{vec\PYGZus{}poid}   \PYG{o}{=} \PYG{n}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{multlist}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{vec\PYGZus{}poid}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{k}{return}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii}
\label{\detokenize{cyclik_asciiv1:cyclik-ascii}}\label{\detokenize{cyclik_asciiv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_asciiv1:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_asciiv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}
\newpage

\section{crypt\_final}
\label{\detokenize{crypt_finalv1:crypt-final}}\label{\detokenize{crypt_finalv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_finalv1:algorithm}}
\sphinxAtStartPar
The layout procedure to organise crypting results.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted strin and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The crypted list as a string with correct separators

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_finalv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{crypt}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp}
\label{\detokenize{slurpv1:slurp}}\label{\detokenize{slurpv1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurpv1:algorithm}}
\sphinxAtStartPar
This method allow us to rebuild a str list of crypted terms using separators set.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurpv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{resolve}
\label{\detokenize{resolvev1:resolve}}\label{\detokenize{resolvev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{resolvev1:algorithm}}
\sphinxAtStartPar
This method compute the chained 2nd order equations to solve the numeric suit.
It permit us to get the ASCII values as a list.
To solve the system you have to instance the solver with the square root of term 0.
Once theorem zero done, you will apply the equation solver with square root of the 0\sphinxhyphen{}term as b,
a as 1 and c as \sphinxhyphen{}following term.
The algorithm sort the roots and take only positives ones.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The computed multiplied list to solve
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : A list containing solved terms.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{resolvev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{tmp2} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp2} \PYG{o}{=} \PYG{n}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{x}\PYG{o}{=}\PYG{n}{tmp2}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{tmp2}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{decrypt\_procedure}
\label{\detokenize{decrypt_procedurev1:decrypt-procedure}}\label{\detokenize{decrypt_procedurev1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{decrypt_procedurev1:algorithm}}
\sphinxAtStartPar
This method manage the decrypting procedure.
It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Build the full key since the key argument}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Split the string since separators via slurp method}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Apply the inv\_tranpose\_base method to get the uncrypted terms}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Solve the cumulated multiplued weigth with the equation solver}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Convert the int list as result to ASCII chain}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw crypted text as string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The uncrypted text.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{decrypt_procedurev1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base}\PYG{o}{=}\PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{tmp} \PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find}\PYG{o}{=}\PYG{n}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}liste}\PYG{o}{=}\PYG{n}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{n}{int\PYGZus{}liste}\PYG{o}{=}\PYG{n}{resolve}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}liste}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{int\PYGZus{}liste}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Algorithm v2}
\label{\detokenize{basetestrecursivev3:raptor-cryptographic-algorithm-v2}}\label{\detokenize{basetestrecursivev3::doc}}
\newpage
\section{Description of Crypter}
\label{\detokenize{Description of Crypterv2:description-of-crypter}}\label{\detokenize{Description of Crypterv2::doc}}
\sphinxAtStartPar
Welcome to Raptor cryptographic help

\sphinxAtStartPar
This following instructions give you the full light on the given cryptographic algorithm “Raptor”.
In a firts time I will explain the main algorithm rules. Each of the function used can be found on the
full source code and have a dedicated help section.

\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of Crypterv2:algorithm}}
\sphinxAtStartPar
This is the main algorithm of the program.
It allows from a system argv string to crypt it and get a string,key couple as result.
We will use this following variables to make it work :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : A list of list containing all the necessary Base table from Base 11 to Base 37

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : 2 as default, it means the minimum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} :  37 as default, it means the maximum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{chaine} : The string chain to crypt as system argv argument

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{choice} : A choice variable to manage the main loop (continue or quit)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Range} : Define the range of values generate into the corresponding Numeric Base a the begining

\end{itemize}

\sphinxAtStartPar
The return of the algorithm is ruled by the following variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The final half key as key

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The final crypted strin as string.

\end{itemize}

\sphinxAtStartPar
The alorithm is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generating the first step Base table} for each necessary numeric base via the function table and splitTable

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Recursive build of the full Base table} since the first step table using functions :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{rec\_table\_construct\_lvl1} : It draw the ‘zero theorem’ of Table construction since the first step. Must be considered as te first loop of recursive builder algorithm

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{rec\_manage} : It draw the full Base Table using recursive loop

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Initialization} : Instanciation of the local varables to manipulate the algorithm

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Split} : I crypt the data string as input using slices of the string vector. Using a loop, I will crypt each slices independantly from each others. It permits us to have a full crypted string more complex than the first version of algorithm

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Crypting Slices} : Once each slices properly cutted, we have to crypt each of them using the crypt\_procedure automated on a loop coursing each of them.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Manage Slices} : The crypted slices are managed via a second level separators set wich define a second level of crypting tree. In fact each term of a slice is using a first level of separators, it give a one\sphinxhyphen{}level tree. The second level permit to complexify the full algorithm result.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rebuild results} : Finally, the crypt\_procedure function is used to associate each crypted slice to his key and draw a correct interpretated result as list of couple (crypted string/integer key)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Return results} : The couple full result rebuilded from slices couple is organized from the second level separators to draw a 2\sphinxhyphen{}level tree

\end{itemize}

\sphinxAtStartPar
This algorithm is stable in his domain and must be used on it.
Please not to try bigger data slice and automate it via shell script if necessary.
It should be used as a data crypter using a top level slicer and manager (from the shell script as exemple).

\sphinxAtStartPar
See source below to more explanation.


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of Crypterv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{}system check routine}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}init routine}
\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}second level local declaration}
\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{}definition of sets}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}main algorithm}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi} \PYG{o}{=} \PYG{l+m+mi}{0}

        \PYG{n}{res} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{userchoice}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{chaine} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{chaine}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer la chaine à crypter : }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
                \PYG{n}{longi}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{=}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{long\PYGZus{}crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testc} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{n}{testk} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{testc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{testk}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{p}{)}
                        \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                        \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}

        \PYG{n}{int\PYGZus{}chaine}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n}{testc}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}

        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Clé unique : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}

        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{testk}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine décryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{clean\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}crypter}
\label{\detokenize{DescriptionofDecrypterv2:description-of-de-crypter}}\label{\detokenize{DescriptionofDecrypterv2::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofDecrypterv2:algorithm}}
\sphinxAtStartPar
This is the main solver algorithm program.
It allow us to decrypt datas slices crypted with the version 1 of the Raptor Cryptographic Algorithm.
To solve I need thse following variables :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The input crypted string storage

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : The minimum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} : The maximum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : The list of list containing the Base Table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The key of the algorithm, the decrypting process absolutely need this key.

\end{itemize}

\sphinxAtStartPar
The solving procedure is ruled by the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generating the Base Table} and store it into my table2 variable

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting inputs} known as crypted string and his associated key.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decrypting process} using the decrypt\_procedure method (see documentation)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store and return} the results of decrypting process

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofDecrypterv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{}system check routine}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}init routine}
\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}second level local declaration}
\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{}definition of sets}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}main algorithm}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi} \PYG{o}{=} \PYG{l+m+mi}{0}

        \PYG{n}{res} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Chaine cryptée : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Clé unique : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{120}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{=}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{testkey}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine décryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{clean\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{reverse}
\label{\detokenize{reversev2:reverse}}\label{\detokenize{reversev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{reversev2:algorithm}}
\sphinxAtStartPar
A function to reverse a string as argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameter}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{s}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The string to reverse
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The reversed string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{reversev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{:}
        \PYG{n+nb}{str}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{n+nb}{str}
\PYG{k}{return} \PYG{n+nb}{str}
\end{sphinxVerbatim}

\newpage
\section{splitTable}
\label{\detokenize{splitTablev2:splittable}}\label{\detokenize{splitTablev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{splitTable}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitTablev2:algorithm}}
\sphinxAtStartPar
Split a string as array from the given separator.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The list to split
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list}  : The splitted list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitTablev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local\PYGZus{}list}\PYG{o}{=}\PYG{n}{table}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res\PYGZus{}list}
\end{sphinxVerbatim}

\newpage
\section{table}
\label{\detokenize{tablev2:table}}\label{\detokenize{tablev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{table}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tablev2:algorithm}}
\sphinxAtStartPar
Base table recursive builder.
The generated Base table array is defined via :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{base} : Define the base to begin the table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{debut} : Define the first value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fin} : Define the last value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{inc} : Define the incrementation step

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first base of the table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{debut}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{fin}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The last value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{inc}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The value of incrementation step
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Str} : A string containing all the base generated representing the array (see conversion later)

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tablev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{powIndex}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{fin}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fin}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{debut}\PYG{p}{,}\PYG{n}{fin}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{current}\PYG{o}{=}\PYG{n}{i}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{count}\PYG{o}{=}\PYG{n}{powIndex}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{powIndex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                        \PYG{k}{else}\PYG{p}{:}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                                        \PYG{k}{else}\PYG{p}{:}
                                                \PYG{n}{count}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{l+m+mi}{1}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
                        \PYG{n}{current}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{p}{)}
                \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{reverse}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{return} \PYG{n}{represent}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_lvl1}
\label{\detokenize{rec_table_construct_lvl1v2:rec-table-construct-lvl1}}\label{\detokenize{rec_table_construct_lvl1v2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construct_lvl1v2:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm permit to edit much larger array from existing original base table.
Ths algorithm must be used as the init loop of the final recursive method (see rec\_manage method)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base table array
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current numeric base as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{powindex}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The pow index as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{last}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The Recursively builded Base table as list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construct_lvl1v2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lettrebase}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{powindex} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{del} \PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{i}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{powindex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{lettrebase}\PYG{p}{[}\PYG{n}{powindex}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_final}
\label{\detokenize{rec_table_construc_finalv2:rec-table-construct-final}}\label{\detokenize{rec_table_construc_finalv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{lvl}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construc_finalv2:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm manage array building since 2 levels of recursive construction.
=\textgreater{} Do not use for the first recursive building loop


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The first recursive level builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base to treat as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{lvl}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The level of recursivity in construction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully specified level recursivity builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construc_finalv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{basetable}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{basetable}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{eat} \PYG{o+ow}{in} \PYG{n}{basetable}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{table}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{eat}\PYG{o}{+}\PYG{n}{this}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_manage}
\label{\detokenize{rec_managev2:rec-manage}}\label{\detokenize{rec_managev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_managev2:algorithm}}
\sphinxAtStartPar
A recursivity manager to build properly the base table.
It must be used to map the numeric values into base values.
This method allow contruction of hundreds of thousand values table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The initial Base table to complete
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_managev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{3}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1000000}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}
                \PYG{n}{j}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{table}
\end{sphinxVerbatim}

\newpage
\section{ascii\_to\_int}
\label{\detokenize{ascii_to_intv2:ascii-to-int}}\label{\detokenize{ascii_to_intv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{ascii_to_intv2:algorithm}}
\sphinxAtStartPar
Utils method : ascii to integer converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The string to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : A list containing all integers values since ASCII.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{ascii_to_intv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{letter} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{int\_to\_ascii}
\label{\detokenize{int_to_asciiv2:int-to-ascii}}\label{\detokenize{int_to_asciiv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{int_to_asciiv2:algorithm}}
\sphinxAtStartPar
Utils method : integer to ascii converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Description}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The int list to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The converted ASCII string since int list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{int_to_asciiv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cryptChaine}
\label{\detokenize{cryptChainev2:cryptchaine}}\label{\detokenize{cryptChainev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cryptChaine}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cryptChainev2:algorithm}}
\sphinxAtStartPar
The simple method to crypt an ascii string as integer list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The converted int list since an ascii string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all fully builded Base Table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : A string list containing all the base crypted values. Must be used as a crypted list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cryptChainev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{local\_table\_dico}
\label{\detokenize{local_table_dicov2:local-table-dico}}\label{\detokenize{local_table_dicov2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{local\PYGZus{}table\PYGZus{}dico}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{local_table_dicov2:algorithm}}
\sphinxAtStartPar
Utils method : A method to convert a Base table to Python dictionnary


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table2}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all the fully builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{rangeB}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the max step of incrementation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Dictionnary} : A dictionnary representing the specified Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{local_table_dicov2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{str\PYGZus{}base}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{rangeB}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rangeB}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}base}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{str\PYGZus{}base}
\end{sphinxVerbatim}

\newpage
\section{limit\_range}
\label{\detokenize{limit_rangev2:limit-range}}\label{\detokenize{limit_rangev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{limit\PYGZus{}range}\PYG{p}{(}\PYG{n}{Range}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{limit_rangev2:algorithm}}
\sphinxAtStartPar
Utils method : A method to limit the Base range


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Range}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The range as a limit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The limited by range res.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{limit_rangev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{Range}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{Range}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{base\_key}
\label{\detokenize{base_keyv2:base-key}}\label{\detokenize{base_keyv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{base_keyv2:algorithm}}
\sphinxAtStartPar
This is the key builder.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The base index list as a starting builder for key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : the builded key from index base list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{base_keyv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{36}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{10}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_poids}
\label{\detokenize{vec_poidsv2:vec-poids}}\label{\detokenize{vec_poidsv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_poidsv2:algorithm}}
\sphinxAtStartPar
Compute the vectorial cumulated weight of the list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The integer list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed accumulated weigth integer list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_poidsv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_1\_poids}
\label{\detokenize{vec_1_poidsv2:vec-1-poids}}\label{\detokenize{vec_1_poidsv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}1\PYGZus{}poids}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_1_poidsv2:algorithm}}
\sphinxAtStartPar
Compute the inverse of the vectorial cumulated weigth computation.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{vec\_poids}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The weigth as an integer list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed list containing the inverse operation of vec\_poids method

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_1_poidsv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{equa\_2\_nd}
\label{\detokenize{equa_2_ndv2:equa-2-nd}}\label{\detokenize{equa_2_ndv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{equa_2_ndv2:algorithm}}
\sphinxAtStartPar
Utils : An 2nd order equation solver


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The a coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The b coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{c}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The c coefficient
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float} : The solved equation positive root

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{equa_2_ndv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{racine1} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{racine2} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{delta} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{delta}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{racine1} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
        \PYG{n}{racine2} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{racine1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine1}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine2}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{multlist}
\label{\detokenize{multlistv2:multlist}}\label{\detokenize{multlistv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multlist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{multlistv2:algorithm}}
\sphinxAtStartPar
Utils : A point by point list multiplier


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float list} : The computed point by point multiplication

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{multlistv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{transpose\_base}
\label{\detokenize{transpose_basev2:transpose-base}}\label{\detokenize{transpose_basev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{transpose_basev2:algorithm}}
\sphinxAtStartPar
A method to transpose an integer list to the corresponding key’s base index
=\textgreater{} The result will be a succession of transposed values from differents integers to differents base


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
the integer converted since ASCII list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The full Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The crypted list as String list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{transpose_basev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else} \PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{inv\_transpose\_base}
\label{\detokenize{inv_transpose_basev2:inv-transpose-base}}\label{\detokenize{inv_transpose_basev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{inv_transpose_basev2:algorithm}}
\sphinxAtStartPar
The inverse method to decrypt a str list of base transposed values


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The crypted list as String list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The full Base table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The decrypted list as integers

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{inv_transpose_basev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_procedure}
\label{\detokenize{crypt_procedurev2:crypt-procedure}}\label{\detokenize{crypt_procedurev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_procedurev2:algorithm}}
\sphinxAtStartPar
The crypter manager to orchestrate the crypting procedure.
It works from these steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We convert the given ascii string as integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the Base index list as key from the converted integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We build the second part of the key since the mirror of the Base index list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the cumulated weight of the integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the point by point multiplication between cumulated weigth list and original integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We transpose the multiplied list into the given specified Base from the key}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We associate the crypted strin to the key as return}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The string to crypt
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list tuple (crypt\_lst,key)} : The couple crypted string and key as result. It permits to decrypt any message.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_procedurev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{int\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{n}{base\PYGZus{}keyy}  \PYG{o}{=} \PYG{n}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{vec\PYGZus{}poid}   \PYG{o}{=} \PYG{n}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{multlist}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{vec\PYGZus{}poid}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{k}{return}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii}
\label{\detokenize{cyclik_asciiv2:cyclik-ascii}}\label{\detokenize{cyclik_asciiv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_asciiv2:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_asciiv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_lvl2}
\label{\detokenize{cyclik_ascii_lvl2v2:cyclik-ascii-lvl2}}\label{\detokenize{cyclik_ascii_lvl2v2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_lvl2v2:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs.
Get a second cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_lvl2v2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final}
\label{\detokenize{crypt_finalv2:crypt-final}}\label{\detokenize{crypt_finalv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_finalv2:algorithm}}
\sphinxAtStartPar
The layout procedure to organise crypting results.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted strin and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The crypted list as a string with correct separators

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_finalv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{n}{crypt}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final\_long}
\label{\detokenize{crypt_final_longv2:crypt-final-long}}\label{\detokenize{crypt_final_longv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_final_longv2:algorithm}}
\sphinxAtStartPar
Chaining the final\sphinxhyphen{}level algorithm to get complex crypto\sphinxhyphen{}procedure


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted string and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full second level crypted string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_final_longv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp}
\label{\detokenize{slurpv2:slurp}}\label{\detokenize{slurpv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurpv2:algorithm}}
\sphinxAtStartPar
This method allow us to rebuild a str list of crypted terms using separators set.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurpv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp2}
\label{\detokenize{slurp2v2:slurp2}}\label{\detokenize{slurp2v2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp2}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp2v2:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp method. It defined a second level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp2v2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{miam}
\label{\detokenize{miamv2:miam}}\label{\detokenize{miamv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{miam}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{miamv2:algorithm}}
\sphinxAtStartPar
Key builder from the half key as integer list. It rebuild the missing half with a mirror copy of the first one.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The full key rebuilded from the half key

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{miamv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{key}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{resolve}
\label{\detokenize{resolvev2:resolve}}\label{\detokenize{resolvev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{resolvev2:algorithm}}
\sphinxAtStartPar
This method compute the chained 2nd order equations to solve the numeric suit.
It permit us to get the ASCII values as a list.
To solve the system you have to instance the solver with the square root of term 0.
Once theorem zero done, you will apply the equation solver with square root of the 0\sphinxhyphen{}term as b,
a as 1 and c as \sphinxhyphen{}following term.
The algorithm sort the roots and take only positives ones.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The computed multiplied list to solve
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : A list containing solved terms.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{resolvev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{tmp2} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp2} \PYG{o}{=} \PYG{n}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{x}\PYG{o}{=}\PYG{n}{tmp2}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{tmp2}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}
\newpage

\section{decrypt\_procedure}
\label{\detokenize{decrypt_procedurev2:decrypt-procedure}}\label{\detokenize{decrypt_procedurev2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{decrypt_procedurev2:algorithm}}
\sphinxAtStartPar
This method manage the decrypting procedure.
It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Build the full key since the key argument}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Split the string} since separators via slurp method

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Apply the inv\_tranpose\_base method} to get the uncrypted terms

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Solve the cumulated multiplied weigth} with the equation solver

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Convert the int list} as result to ASCII chain

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw crypted text as string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The uncrypted text.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{decrypt_procedurev2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base}\PYG{o}{=}\PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{tmp} \PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find}\PYG{o}{=}\PYG{n}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}liste}\PYG{o}{=}\PYG{n}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{n}{int\PYGZus{}liste}\PYG{o}{=}\PYG{n}{resolve}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}liste}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{int\PYGZus{}liste}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{split}
\label{\detokenize{splitv2:split}}\label{\detokenize{splitv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitv2:algorithm}}
\sphinxAtStartPar
Split the given string argument ‘chaine’ into slices from threshold size ‘seuil’.
Each of this slices are allowed into the cryptographic algorithm.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The full string to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{seuil}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the threshold size of the slices
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The slices list as result

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{div}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{/}\PYG{n}{seuil}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{j}\PYG{o}{==}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{index}\PYG{o}{=}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{index}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{index}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{tilps}
\label{\detokenize{tilpsv2:tilps}}\label{\detokenize{tilpsv2::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{tilps}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tilpsv2:algorithm}}
\sphinxAtStartPar
The reverse method of the split function. From a given str list, we rebuild the full length string


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The String slices as a list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full striing rebuilded from the slices list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tilpsv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Algorithm v3}
\label{\detokenize{basetestrecursivev4:raptor-cryptographic-algorithm-v3}}\label{\detokenize{basetestrecursivev4::doc}}
\newpage
\section{Description of Crypter}
\label{\detokenize{Description of Crypterv3:description-of-crypter}}\label{\detokenize{Description of Crypterv3::doc}}
\sphinxAtStartPar
Welcom to Raptor cryptographic help

\sphinxAtStartPar
This following instructions give you the full light on the given cryptographic algorithm “Raptor”.
In a firts time I will explain the main algorithm rules. Each of the function used can be found on the
full source code and have a dedicated help section.

\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of Crypterv3:algorithm}}
\sphinxAtStartPar
This is the main algorithm of the program.
It allows from a system argv string to crypt it and get a string,key couple as result.
We will use this following variables to make it work :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : A list of list containing all the necessary Base table from Base 11 to Base 37

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : 2 as default, it means the minimum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} :  37 as default, it means the maximum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{chaine} : The string chain to crypt as system argv argument

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{choice} : A choice variable to manage the main loop (continue or quit)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Range} : Define the range of values generate into the corresponding Numeric Base a the begining

\end{itemize}

\sphinxAtStartPar
The return of the algorithm is ruled by the following variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The final half key as key

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The final crypted strin as string.

\end{itemize}

\sphinxAtStartPar
This is the main Raptor Cryptographic Algorithm v3. It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Initialization} of differents variables and of the Base table via the table generator methods

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Splitting} part of the given raw string as input. This string will be splitted into differents slices, wiche be crypted one by one and associated to his key via the third level separators wich define the third level of the crypting tree.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Crypting procedure} for each of the slices obtained by the split method above. These crypted results will be stored as a list of list, respectively a list of slices, defined by a list of crypted terms.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Manage the results} via slurp2 and slurp3 methods. The results are properly stored at this time to be correctly interpreted later.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Give a wrong path} for decrypting using some fake values to both of crypted txt and key as strings. It means any Brute force attack will be ignored.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Returns} the couple (crypt txt, key) wich is efficient to be decrypted by the solver.

\end{itemize}

\sphinxAtStartPar
This algorithm is stable in his domain and must be used on it.
Please not to try bigger data slice and automate it via shell script if necessary.
It should be used as a data crypter using a top level slicer and manager (from the shell script as exemple).

\sphinxAtStartPar
See source below to more explanation.


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of Crypterv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}

\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{=}\PYG{l+m+mi}{70}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{long\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}crypt}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}crypt}        \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{longii}\PYG{o}{=} \PYG{l+m+mi}{0}

        \PYG{n}{res} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{userchoice}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{chaine} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
                \PYG{n}{chaine}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer la chaine à crypter  (\PYGZgt{}20): }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
                \PYG{n}{longi}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{split}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{longii}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}

        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{=}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{long\PYGZus{}crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp\PYGZus{}crypt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
                                        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}crypt}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testc} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{n}{testk} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testk}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{p}{)}
                                \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}

                        \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testk}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{p}{)}
                                \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl3}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}\PYG{p}{)}
                                        \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}
                                        \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}
        \PYG{n}{int\PYGZus{}chaine}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n}{testc}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{n}{mesqui}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{n}{mesqui}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Clé unique : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}crypter}
\label{\detokenize{DescriptionofDecrypterv3:description-of-de-crypter}}\label{\detokenize{DescriptionofDecrypterv3::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofDecrypterv3:algorithm}}
\sphinxAtStartPar
This is the main solver algorithm program.
It allow us to decrypt datas slices crypted with the version 1 of the Raptor Cryptographic Algorithm.
To solve I need thse following variables :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The input crypted string storage

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : The minimum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} : The maximum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : The list of list containing the Base Table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The key of the algorithm, the decrypting process absolutely need this key.

\end{itemize}

\sphinxAtStartPar
The solving procedure is ruled by the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generating the Base Table} and store it into my table2 variable

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting inputs} known as crypted string and his associated key.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Organize data slice} removing separators via the slurps methods

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decrypting process} using the decrypt\_procedure method (see documentation)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store and return} the results of decrypting process

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofDecrypterv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{Basemin}\PYG{p}{,}\PYG{n}{Basemax}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Range}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{splitTable}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{+}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}

\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{=}\PYG{l+m+mi}{70}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{long\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}crypt}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2} \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}         \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}crypt}        \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi} \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{longii}\PYG{o}{=} \PYG{l+m+mi}{0}

        \PYG{n}{res} \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Clé unique : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{longi}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{longii}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{slurp3}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{testkey} \PYG{o}{=} \PYG{n}{slurp3}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{=}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{testkey}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}

                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl3\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl3\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl3\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp4}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                        \PYG{n}{lvl3\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp4}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{final\PYGZus{}key}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}liste}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{k}{del} \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
                                \PYG{n}{final\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=}\PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{final\PYGZus{}key}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}

        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine décryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{clean\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{Reverse}
\label{\detokenize{reversev3:reverse}}\label{\detokenize{reversev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{reversev3:algorithm}}
\sphinxAtStartPar
A function to reverse a string as argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameter}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{s}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The string to reverse
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The reversed string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{reversev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{str}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{:}
        \PYG{n+nb}{str}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{n+nb}{str}
\PYG{k}{return} \PYG{n+nb}{str}
\end{sphinxVerbatim}

\newpage
\section{splitTable}
\label{\detokenize{splitTablev3:splittable}}\label{\detokenize{splitTablev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{splitTable}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitTablev3:algorithm}}
\sphinxAtStartPar
Split a string as array from the given separator.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The list to split
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The splitted list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitTablev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local\PYGZus{}list}\PYG{o}{=}\PYG{n}{table}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res\PYGZus{}list}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res\PYGZus{}list}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{local\PYGZus{}list}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res\PYGZus{}list}
\end{sphinxVerbatim}

\newpage
\section{table}
\label{\detokenize{tablev3:table}}\label{\detokenize{tablev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{table}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{n}{debut}\PYG{p}{,}\PYG{n}{fin}\PYG{p}{,}\PYG{n}{inc}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tablev3:algorithm}}
\sphinxAtStartPar
Base table recursive builder.
The generated Base table array is defined via :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{base} : Define the base to begin the table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{debut} : Define the first value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fin} : Define the last value of Base table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{inc} : Define the incrementation step

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first base of the table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{debut}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The first value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{fin}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The last value of the table in the given base
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{inc}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The value of incrementation step
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Str} : A string containing all the base generated representing the array (see conversion later)

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tablev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{powIndex}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{fin}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{fin}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{debut}\PYG{p}{,}\PYG{n}{fin}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{current}\PYG{o}{=}\PYG{n}{i}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{n}{base}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{k}{while}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{o}{!=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{count}\PYG{o}{=}\PYG{n}{powIndex}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}
                        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{powIndex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                        \PYG{k}{else}\PYG{p}{:}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                        \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{letter}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                                        \PYG{k}{else}\PYG{p}{:}
                                                \PYG{n}{count}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{l+m+mi}{1}
                                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{current}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                                \PYG{n}{letter}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}
                        \PYG{n}{current}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{current}\PYG{o}{/}\PYG{n}{base}\PYG{p}{)}
                \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{n}{reverse}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}comment this lonely line to run out the program :/}
        \PYG{n}{represent}\PYG{o}{+}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{return} \PYG{n}{represent}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_lvl1}
\label{\detokenize{rec_table_construct_lvl1v3:rec-table-construct-lvl1}}\label{\detokenize{rec_table_construct_lvl1v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{powindex}\PYG{p}{,}\PYG{n}{last}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construct_lvl1v3:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm permit to edit much larger array from existing original base table.
Ths algorithm must be used as the init loop of the final recursive method (see rec\_manage method)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base table array
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current numeric base as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{powindex}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The pow index as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{last}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
unused
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The Recursively builded Base table as list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construct_lvl1v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lettrebase}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{powindex} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{del} \PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{base}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{o}{==}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{i}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{powindex}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{lettrebase}\PYG{p}{[}\PYG{n}{powindex}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{base}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_table\_construct\_final}
\label{\detokenize{rec_table_construc_finalv3:rec-table-construct-final}}\label{\detokenize{rec_table_construc_finalv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{lvl}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_table_construc_finalv3:algorithm}}
\sphinxAtStartPar
Recursive Construction method from the Base table.
The recursive algorithm manage array building since 2 levels of recursive construction.
=\textgreater{} Do not use for the first recursive building loop


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The first recursive level builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base to treat as integer
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{lvl}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The level of recursivity in construction
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully specified level recursivity builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_table_construc_finalv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{basetable}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{base}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{basetable}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{basetable}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{eat} \PYG{o+ow}{in} \PYG{n}{basetable}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{table}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{eat}\PYG{o}{+}\PYG{n}{this}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{rec\_manage}
\label{\detokenize{rec_managev3:rec-manage}}\label{\detokenize{rec_managev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{rec\PYGZus{}manage}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{rec_managev3:algorithm}}
\sphinxAtStartPar
A recursivity manager to build properly the base table.
It must be used to map the numeric values into base values.
This method allow contruction of hundreds of thousand values table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The initial Base table to complete
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The fully builded Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{rec_managev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}lvl1}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{18}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{3}
        \PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
        \PYG{k}{while}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1000000}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{table2}\PYG{o}{=}\PYG{n}{rec\PYGZus{}table\PYGZus{}construct\PYGZus{}final}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}
                \PYG{n}{j}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{n}{table}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{table}
\end{sphinxVerbatim}

\newpage
\section{ascii\_to\_int}
\label{\detokenize{ascii_to_intv3:ascii-to-int}}\label{\detokenize{ascii_to_intv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{ascii_to_intv3:algorithm}}
\sphinxAtStartPar
Utils method : ascii to integer converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The string to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : A list containing all integers values since ASCII.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{ascii_to_intv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{letter} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{int\_to\_ascii}
\label{\detokenize{int_to_asciiv3:int-to-ascii}}\label{\detokenize{int_to_asciiv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{int_to_asciiv3:algorithm}}
\sphinxAtStartPar
Utils method : integer to ascii converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Description}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The int list to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The converted ASCII string since int list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{int_to_asciiv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cryptChaine}
\label{\detokenize{cryptChainev3:cryptchaine}}\label{\detokenize{cryptChainev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cryptChaine}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cryptChainev3:algorithm}}
\sphinxAtStartPar
The simple method to crypt an ascii string as integer list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The converted int list since an ascii string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all fully builded Base Table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : A string list containing all the base crypted values. Must be used as a crypted list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cryptChainev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{local\_table\_dico}
\label{\detokenize{local_table_dicov3:local-table-dico}}\label{\detokenize{local_table_dicov3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{local\PYGZus{}table\PYGZus{}dico}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{local_table_dicov3:algorithm}}
\sphinxAtStartPar
Utils method : A method to convert a Base table to Python dictionnary


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table2}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all the fully builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{rangeB}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the max step of incrementation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Dictionnary} : A dictionnary representing the specified Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{local_table_dicov3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{str\PYGZus{}base}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{rangeB}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rangeB}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}base}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{str\PYGZus{}base}
\end{sphinxVerbatim}

\newpage
\section{limit\_range}
\label{\detokenize{limit_rangev3:limit-range}}\label{\detokenize{limit_rangev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{limit\PYGZus{}range}\PYG{p}{(}\PYG{n}{Range}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{limit_rangev3:algorithm}}
\sphinxAtStartPar
Utils method : A method to limit the Base range


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Range}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The range as a limit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The limited by range res.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{limit_rangev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{Range}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{Range}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{base\_key}
\label{\detokenize{base_keyv3:base-key}}\label{\detokenize{base_keyv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{base_keyv3:algorithm}}
\sphinxAtStartPar
This is the key builder.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The base index list as a starting builder for key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : the builded key from index base list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{base_keyv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{36}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{10}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_poids}
\label{\detokenize{vec_poidsv3:vec-poids}}\label{\detokenize{vec_poidsv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_poidsv3:algorithm}}
\sphinxAtStartPar
Compute the vectorial cumulated weight of the list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The integer list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed accumulated weigth integer list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_poidsv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_1\_poids}
\label{\detokenize{vec_1_poidsv3:vec-1-poids}}\label{\detokenize{vec_1_poidsv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}1\PYGZus{}poids}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_1_poidsv3:algorithm}}
\sphinxAtStartPar
Compute the inverse of the vectorial cumulated weigth computation.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{vec\_poids}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The weigth as an integer list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed list containing the inverse operation of vec\_poids method

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_1_poidsv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{equa\_2\_nd}
\label{\detokenize{equa_2_ndv3:equa-2-nd}}\label{\detokenize{equa_2_ndv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{equa_2_ndv3:algorithm}}
\sphinxAtStartPar
Utils : An 2nd order equation solver


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The a coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The b coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{c}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The c coefficient
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float} : The solved equation positive root

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{equa_2_ndv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{racine1} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{racine2} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{delta} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{delta}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{racine1} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
        \PYG{n}{racine2} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{racine1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine1}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine2}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{multlist}
\label{\detokenize{multlistv3:multlist}}\label{\detokenize{multlistv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multlist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{multlistv3:algorithm}}
\sphinxAtStartPar
Utils : A point by point list multiplier


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float list} : The computed point by point multiplication

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{multlistv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{transpose\_base}
\label{\detokenize{transpose_basev3:transpose-base}}\label{\detokenize{transpose_basev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{transpose_basev3:algorithm}}
\sphinxAtStartPar
A method to transpose an integer list to the corresponding key’s base index
=\textgreater{} The result will be a succession of transposed values from differents integers to differents base


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
the integer converted since ASCII list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The full Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list}: The crypted list as String list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{transpose_basev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else} \PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{inv\_transpose\_base}
\label{\detokenize{inv_transpose_basev3:inv-transpose-base}}\label{\detokenize{inv_transpose_basev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{inv_transpose_basev3:algorithm}}
\sphinxAtStartPar
The inverse method to decrypt a str list of base transposed values


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The crypted list as String list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The full Base table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The decrypted list as integers

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{inv_transpose_basev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_procedure}
\label{\detokenize{crypt_procedurev3:crypt-procedure}}\label{\detokenize{crypt_procedurev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_procedurev3:algorithm}}
\sphinxAtStartPar
The crypter manager to orchestrate the crypting procedure.
It works from these steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We convert the given ascii string as integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the Base index list as key from the converted integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We build the second part of the key since the mirror of the Base index list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the cumulated weight of the integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the point by point multiplication between cumulated weigth list and original integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We transpose the multiplied list into the given specified Base from the key}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We associate the crypted strin to the key as return}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The string to crypt
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list tuple} : The couple crypted string and key as result. It permits to decrypt any message.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_procedurev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{int\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{n}{base\PYGZus{}keyy}  \PYG{o}{=} \PYG{n}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{vec\PYGZus{}poid}   \PYG{o}{=} \PYG{n}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{multlist}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{vec\PYGZus{}poid}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{k}{return}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii}
\label{\detokenize{cyclik_asciiv3:cyclik-ascii}}\label{\detokenize{cyclik_asciiv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_asciiv3:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_asciiv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_lvl2}
\label{\detokenize{cyclik_ascii_lvl2v3:cyclik-ascii-lvl2}}\label{\detokenize{cyclik_ascii_lvl2v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_lvl2v3:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs.
Get a second cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_lvl2v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_lvl3}
\label{\detokenize{cyclik_ascii_lvl3v3:cyclik-ascii-lvl3}}\label{\detokenize{cyclik_ascii_lvl3v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}lvl3}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_lvl3v3:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into Upper letters from A to L.
Get a third cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_lvl3v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_mesquin}
\label{\detokenize{cyclik_ascii_mesquinv3:cyclik-ascii-mesquin}}\label{\detokenize{cyclik_ascii_mesquinv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}mesquin}\PYG{p}{(}\PYG{n}{current}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_mesquinv3:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into Upper letters from M to Z.
Get a third cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_mesquinv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{mesquin}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final}
\label{\detokenize{crypt_finalv3:crypt-final}}\label{\detokenize{crypt_finalv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_finalv3:algorithm}}
\sphinxAtStartPar
The layout procedure to organise crypting results.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted strin and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The crypted list as a string with correct separators

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_finalv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{n}{crypt}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final\_long}
\label{\detokenize{crypt_final_longv3:crypt-final-long}}\label{\detokenize{crypt_final_longv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_final_longv3:algorithm}}
\sphinxAtStartPar
Chaining the final\sphinxhyphen{}level algorithm to get complex crypto\sphinxhyphen{}procedure


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted string and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full second level crypted string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_final_longv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp}
\label{\detokenize{slurpv3:slurp}}\label{\detokenize{slurpv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurpv3:algorithm}}
\sphinxAtStartPar
This method allow us to rebuild a str list of crypted terms using separators set.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurpv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp2}
\label{\detokenize{slurp2v3:slurp2}}\label{\detokenize{slurp2v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp2}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp2v3:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp method. It defined a second level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list}: The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp2v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp3}
\label{\detokenize{slurp3v3:slurp3}}\label{\detokenize{slurp3v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp3}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp3v3:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp2 method. It defined a third level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp3v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{mesquin}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{tmp}
\end{sphinxVerbatim}

\newpage
\section{slurp4}
\label{\detokenize{slurp4v3:slurp4}}\label{\detokenize{slurp4v3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp4}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp4v3:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp2 method. It defined a third level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp4v3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{miam}
\label{\detokenize{miamv3:miam}}\label{\detokenize{miamv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{miam}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{miamv3:algorithm}}
\sphinxAtStartPar
Key builder from the half key as integer list. It rebuild the missing half with a mirror copy of the first one.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The full key rebuilded from the half key

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{miamv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{key}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{resolve}
\label{\detokenize{resolvev3:resolve}}\label{\detokenize{resolvev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{resolvev3:algorithm}}
\sphinxAtStartPar
This method compute the chained 2nd order equations to solve the numeric suit.
It permit us to get the ASCII values as a list.
To solve the system you have to instance the solver with the square root of term 0.
Once theorem zero done, you will apply the equation solver with square root of the 0\sphinxhyphen{}term as b,
a as 1 and c as \sphinxhyphen{}following term.
The algorithm sort the roots and take only positives ones.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The computed multiplied list to solve
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : A list containing solved terms.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{resolvev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{tmp2} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp2} \PYG{o}{=} \PYG{n}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{x}\PYG{o}{=}\PYG{n}{tmp2}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{tmp2}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{decrypt\_procedure}
\label{\detokenize{decrypt_procedurev3:decrypt-procedure}}\label{\detokenize{decrypt_procedurev3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{decrypt_procedurev3:algorithm}}
\sphinxAtStartPar
This method manage the decrypting procedure.
It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Build the full key} since the key argument

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Split the string} since separators via slurp method

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Apply the inv\_tranpose\_base method} to get the uncrypted terms

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Solve the cumulated multiplied weigth} with the equation solver

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Convert the int list} as result to ASCII chain

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw crypted text as string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The uncrypted text.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{decrypt_procedurev3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base}\PYG{o}{=}\PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{tmp} \PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find}\PYG{o}{=}\PYG{n}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{base}\PYG{o}{+}\PYG{o}{=}\PYG{n}{tmp}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Complexify}
\PYG{n}{tmp\PYGZus{}liste}\PYG{o}{=}\PYG{n}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{n}{int\PYGZus{}liste}\PYG{o}{=}\PYG{n}{resolve}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}liste}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{int\PYGZus{}liste}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{split}
\label{\detokenize{splitv3:split}}\label{\detokenize{splitv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitv3:algorithm}}
\sphinxAtStartPar
Split the given string argument ‘chaine’ into slices from threshold size ‘seuil’.
Each of this slices are allowed into the cryptographic algorithm.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The full string to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{seuil}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the threshold size of the slices
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The slices list as result

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{div}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{/}\PYG{n}{seuil}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{j}\PYG{o}{==}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{index}\PYG{o}{=}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{index}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{index}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{tilps}
\label{\detokenize{tilpsv3:tilps}}\label{\detokenize{tilpsv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{tilps}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tilpsv3:algorithm}}
\sphinxAtStartPar
The reverse method of the split function. From a given str list, we rebuild the full length string


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The String slices as a list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full striing rebuilded from the slices list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tilpsv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{mesqui}
\label{\detokenize{mesquiv3:mesqui}}\label{\detokenize{mesquiv3::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mesqui}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{mesquiv3:algorithm}}
\sphinxAtStartPar
This method is used to create a wrong path of decrypting method.
Using a similar Separators terms, I define a ‘fake’ terms list wich have absolutely no meanings for the rest of the algorithm.
Using it as the last step of algorithm, it doesn’t allow any brute force attack to decrypt.
The threshold value ‘seuil’ will define the amount of distribution of fake separators.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{txt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{seuil}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The threshold variable to assign the ‘fake terms’ length
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The fully ‘fake splitted’ crypted string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{mesquiv3:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{txt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}
                \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}mesquin}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Algorithm v3.1}
\label{\detokenize{basetestrecursivev4.2:raptor-cryptographic-algorithm-v3-1}}\label{\detokenize{basetestrecursivev4.2::doc}}
\sphinxAtStartPar
This is the main Raptor Cryptographic Algorithm v3.1.
It use the base\_opt module to build Base Table array and follow the same principe of olders ones adding the new feature of dynamically complement results values.

\newpage
\section{Description of De\sphinxhyphen{}crypter}
\label{\detokenize{Description of Crypterv3.1:description-of-de-crypter}}\label{\detokenize{Description of Crypterv3.1::doc}}
\sphinxAtStartPar
Welcom to Raptor cryptographic help

\sphinxAtStartPar
This following instructions give you the full light on the given cryptographic algorithm “Raptor”.
In a firts time I will explain the main algorithm rules. Each of the function used can be found on the
full source code and have a dedicated help section.

\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of Crypterv3.1:algorithm}}\begin{description}
\item[{This is the main algorithm of the program.}] \leavevmode
\sphinxAtStartPar
It allows from a system argv string to crypt it and get a string,key couple as result.
We will use this following variables to make it work :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : A list of list containing all the necessary Base table from Base 11 to Base 37

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : 2 as default, it means the minimum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} :  37 as default, it means the maximum base index to generate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{chaine} : The string chain to crypt as system argv argument

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{choice} : A choice variable to manage the main loop (continue or quit)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Range} : Define the range of values generate into the corresponding Numeric Base a the begining

\end{itemize}

\sphinxAtStartPar
The return of the algorithm is ruled by the following variables:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The final half key as key

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The final crypted strin as string.

\end{itemize}

\sphinxAtStartPar
This is the main Raptor Cryptographic Algorithm v3. It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Initialization} of differents variables and of the Base table via the table generator methods

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Splitting} part of the given raw string as input. This string will be splitted into differents slices, wiche be crypted one by one and associated to his key via the third level separators wich define the third level of the crypting tree.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Crypting procedure} for each of the slices obtained by the split method above. These crypted results will be stored as a list of list, respectively a list of slices, defined by a list of crypted terms.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Manage the results} via slurp2 and slurp3 methods. The results are properly stored at this time to be correctly interpreted later.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Give a wrong path} for decrypting using some fake values to both of crypted txt and key as strings. It means any Brute force attack will be ignored.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Returns} the couple (crypt txt, key) wich is efficient to be decrypted by the solver.

\end{itemize}

\sphinxAtStartPar
This algorithm is stable in his domain and must be used on it.
Please not to try bigger data slice and automate it via shell script if necessary.
It should be used as a data crypter using a top level slicer and manager (from the shell script as exemple).

\sphinxAtStartPar
See source below to more explanation.

\end{description}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of Crypterv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{=}\PYG{l+m+mi}{70}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{long\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}      \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}crypt}        \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}    \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}    \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}      \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}crypt}           \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{testkey}             \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}             \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt}           \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi}               \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{longii}              \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{res}                 \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{userchoice}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{chaine} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{chaine}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer la chaine à crypter : }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
                \PYG{n}{longi}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{split}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{longii}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{=}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{long\PYGZus{}crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{tmp\PYGZus{}crypt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
                                        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}crypt}\PYG{p}{)}
                        \PYG{c+c1}{\PYGZsh{} print(long\PYGZus{}crypt[\PYGZhy{}1][0])}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testc} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
                \PYG{n}{testk} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testk}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{p}{)}
                                \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{c+c1}{\PYGZsh{} print(long\PYGZus{}long\PYGZus{}crypt[l])}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testc}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{testk}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}\PYG{p}{)}
                                \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}
                                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}l = \PYGZdq{}+str(l)+\PYGZdq{} | len long[l] = \PYGZdq{}+str(len(long\PYGZus{}long\PYGZus{}crypt[l][0])))}
                                \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{long\PYGZus{}long\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}lvl3}\PYG{p}{(}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}\PYG{p}{)}
                                        \PYG{n}{testc}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}
                                        \PYG{n}{testk}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}
                \PYG{c+c1}{\PYGZsh{} print(testc)}
                \PYG{c+c1}{\PYGZsh{} print(testk)}
        \PYG{n}{int\PYGZus{}chaine}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{testkey}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{testk}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n}{res}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{raw\PYGZus{}txt} \PYG{o}{+}\PYG{o}{=} \PYG{n}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n}{testc}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{n}{mesqui}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{n}{mesqui}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Clé unique : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}crypter}
\label{\detokenize{DescriptionofDecrypterv3.1:description-of-de-crypter}}\label{\detokenize{DescriptionofDecrypterv3.1::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofDecrypterv3.1:algorithm}}
\sphinxAtStartPar
\sphinxstylestrong{Description of the Main Raptor’s Cryptographic Algorithm}

\sphinxAtStartPar
This is the main solver algorithm program.
It allow us to decrypt datas slices crypted with the version 1 of the Raptor Cryptographic Algorithm.
To solve I need thse following variables :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{raw\_txt} : The input crypted string storage

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemin} : The minimum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Basemax} : The maximum Base index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{table2} : The list of list containing the Base Table

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{testkey} : The key of the algorithm, the decrypting process absolutely need this key.

\end{itemize}

\sphinxAtStartPar
The solving procedure is ruled by the following steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generating the Base Table} and store it into my table2 variable

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting inputs} known as crypted string and his associated key.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Organize data slice} removing separators via the slurps methods

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decrypting process} using the decrypt\_procedure method (see documentation)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Store and return} the results of decrypting process

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofDecrypterv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k+kn}{as} \PYG{n+nn}{m}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{represent}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{table2} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{dic} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{main\PYGZus{}dic}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{chaine}\PYG{o}{=}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)}\PYG{o}{!=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{l+m+mi}{37}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else} \PYG{p}{:}
        \PYG{n}{Basemin} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Basemax} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{Range}   \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Basemin}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{2} \PYG{o+ow}{or} \PYG{n}{Basemax}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{37}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Affichage impossible veuillez selectionner une plage de valeure contenue dans [2,36]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n+nb}{exit}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{maxi}\PYG{o}{=}\PYG{n}{Basemax}\PYG{o}{\PYGZhy{}}\PYG{n}{Basemin}
\PYG{n}{table2}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{longi}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{seuil} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{=}\PYG{l+m+mi}{70}
\PYG{n}{choice} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{userchoice}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl2}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{sep\PYGZus{}lvl3}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{long\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}chaine}      \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{long\PYGZus{}crypt}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testc}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{testk}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{int\PYGZus{}chaine}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}crypt}        \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}


\PYG{k}{while}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} init\PYGZus{}all()}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl3}    \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{current\PYGZus{}sep\PYGZus{}lvl2}    \PYG{o}{=}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}      \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}crypt}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}crypt}     \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{testk}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}            \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}       \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}    \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{n}{tmp\PYGZus{}crypt}           \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}
        \PYG{n}{testkey}             \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{raw\PYGZus{}txt}             \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{clean\PYGZus{}txt}           \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{n}{longi}               \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{longii}              \PYG{o}{=} \PYG{l+m+mi}{0}
        \PYG{n}{res}                 \PYG{o}{=} \PYG{p}{(}\PYG{p}{)}

        \PYG{n}{raw\PYGZus{}txt}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez entrer la chaine cryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{testkey}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Veuillez saisir la clé : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil}\PYG{o}{*}\PYG{l+m+mi}{6} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
                \PYG{n}{longi}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{split}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{seuil\PYGZus{}lvl2}\PYG{o}{*}\PYG{l+m+mi}{6}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{long\PYGZus{}long\PYGZus{}chaine}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{split}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}long\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{longii}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}

        \PYG{n}{raw\PYGZus{}txt} \PYG{o}{=} \PYG{n}{slurp3}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{testkey} \PYG{o}{=} \PYG{n}{slurp3}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{longi} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{clean\PYGZus{}txt} \PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{,}\PYG{n}{testk}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longi}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{c+c1}{\PYGZsh{} print(lvl2\PYGZus{}liste)}
                        \PYG{c+c1}{\PYGZsh{} print(lvl2\PYGZus{}key)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{c+c1}{\PYGZsh{} print(lvl2\PYGZus{}key\PYGZus{}miam)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=} \PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{longii}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{lvl3\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl3\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl3\PYGZus{}liste} \PYG{o}{=} \PYG{n}{slurp4}\PYG{p}{(}\PYG{n}{raw\PYGZus{}txt}\PYG{p}{)}
                        \PYG{n}{lvl3\PYGZus{}key}   \PYG{o}{=} \PYG{n}{slurp4}\PYG{p}{(}\PYG{n}{testkey}\PYG{p}{)}
                        \PYG{n}{lvl2\PYGZus{}liste} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key}   \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{n}{final\PYGZus{}key}  \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}liste}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{slurp2}\PYG{p}{(}\PYG{n}{lvl3\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                                \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{miam}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                                        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}miam\PYGZdq{})}
                                        \PYG{c+c1}{\PYGZsh{} print(lvl2\PYGZus{}key\PYGZus{}miam)}
                                \PYG{k}{del} \PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
                                \PYG{n}{final\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}key\PYGZus{}miam}\PYG{p}{)}
                                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}final\PYGZdq{})}
                                \PYG{c+c1}{\PYGZsh{} print(final\PYGZus{}key)}
                                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}liste : \PYGZdq{}+str(len(lvl2\PYGZus{}liste))+\PYGZdq{} | key \PYGZdq{}+str(len(final\PYGZus{}key)))}
                                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                                        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}lvl2[i][k] : \PYGZdq{})}
                                        \PYG{c+c1}{\PYGZsh{} print(lvl2\PYGZus{}liste[i][k])}
                                        \PYG{c+c1}{\PYGZsh{} print(final\PYGZus{}key[0][k])}
                                        \PYG{n}{clean\PYGZus{}txt}\PYG{o}{+}\PYG{o}{=}\PYG{n}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{lvl2\PYGZus{}liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{final\PYGZus{}key}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table2}\PYG{p}{)}
                                        \PYG{c+c1}{\PYGZsh{} print(str(k) + \PYGZdq{}/\PYGZdq{} + str(len(lvl2\PYGZus{}liste[i])\PYGZhy{}2))}
                                \PYG{c+c1}{\PYGZsh{} print(str(i)+\PYGZdq{} / \PYGZdq{}+str(len(lvl2\PYGZus{}key)\PYGZhy{}1))}

        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Chaine décryptée : }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{print}\PYG{p}{(}\PYG{n}{clean\PYGZus{}txt}\PYG{p}{)}
        \PYG{n}{choice}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c)ontinuer ou q)uitter}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{choice}\PYG{o}{!=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{userchoice}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\newpage
\section{ascii\_to\_int}
\label{\detokenize{ascii_to_intv3.1:ascii-to-int}}\label{\detokenize{ascii_to_intv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{ascii_to_intv3.1:algorithm}}
\sphinxAtStartPar
Utils method : ascii to integer converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The string to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : A list containing all integers values since ASCII.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{ascii_to_intv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{letter} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{letter}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{int\_to\_ascii}
\label{\detokenize{int_to_asciiv3.1:int-to-ascii}}\label{\detokenize{int_to_asciiv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{int_to_asciiv3.1:algorithm}}
\sphinxAtStartPar
Utils method : integer to ascii converter.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Description}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The int list to convert
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The converted ASCII string since int list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{int_to_asciiv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cryptChaine}
\label{\detokenize{cryptChainev3.1:cryptchaine}}\label{\detokenize{cryptChainev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cryptChaine}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cryptChainev3.1:algorithm}}
\sphinxAtStartPar
The simple method to crypt an ascii string as integer list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{to\_crypt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The converted int list since an ascii string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all fully builded Base Table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : A string list containing all the base crypted values. Must be used as a crypted list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cryptChainev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{to\PYGZus{}crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{local\_table\_dico}
\label{\detokenize{local_table_dicov3.1:local-table-dico}}\label{\detokenize{local_table_dicov3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{local\PYGZus{}table\PYGZus{}dico}\PYG{p}{(}\PYG{n}{table2}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{local_table_dicov3.1:algorithm}}
\sphinxAtStartPar
Utils method : A method to convert a Base table to Python dictionnary


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table2}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
An array containing all the fully builded Base table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the Base index
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{rangeB}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the max step of incrementation
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{Dictionnary} : A dictionnary representing the specified Base table

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{local_table_dicov3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{str\PYGZus{}base}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{rangeB}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rangeB}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rangeB}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}base}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{table2}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{str\PYGZus{}base}
\end{sphinxVerbatim}

\newpage
\section{limit\_range}
\label{\detokenize{limit_rangev3.1:limit-range}}\label{\detokenize{limit_rangev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{limit\PYGZus{}range}\PYG{p}{(}\PYG{n}{Range}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{limit_rangev3.1:algorithm}}
\sphinxAtStartPar
Utils method : A method to limit the Base range


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{Range}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The range as a limit
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current Base index
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The limited by range res.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{limit_rangev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{Range}\PYG{o}{\PYGZgt{}}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{=}\PYG{n}{Range}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{base\_key}
\label{\detokenize{base_keyv3.1:base-key}}\label{\detokenize{base_keyv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{base_keyv3.1:algorithm}}
\sphinxAtStartPar
This is the key builder.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The base index list as a starting builder for key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : the builded key from index base list.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{base_keyv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{36}\PYG{p}{)}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{10}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_poids}
\label{\detokenize{vec_poidsv3.1:vec-poids}}\label{\detokenize{vec_poidsv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_poidsv3.1:algorithm}}
\sphinxAtStartPar
Compute the vectorial cumulated weight of the list.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{int\_chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The integer list to treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed accumulated weigth integer list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_poidsv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{vec\_1\_poids}
\label{\detokenize{vec_1_poidsv3.1:vec-1-poids}}\label{\detokenize{vec_1_poidsv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vec\PYGZus{}1\PYGZus{}poids}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{vec_1_poidsv3.1:algorithm}}
\sphinxAtStartPar
Compute the inverse of the vectorial cumulated weigth computation.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{vec\_poids}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The weigth as an integer list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The computed list containing the inverse operation of vec\_poids method

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{vec_1_poidsv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{vec\PYGZus{}poids}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{equa\_2\_nd}
\label{\detokenize{equa_2_ndv3.1:equa-2-nd}}\label{\detokenize{equa_2_ndv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{equa_2_ndv3.1:algorithm}}
\sphinxAtStartPar
Utils : An 2nd order equation solver


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The a coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The b coefficient
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{c}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int / float}
&
\sphinxAtStartPar
The c coefficient
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float} : The solved equation positive root

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{equa_2_ndv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{racine1} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{racine2} \PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{delta} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{delta}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{racine1} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
        \PYG{n}{racine2} \PYG{o}{=} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{delta}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{racine1}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine1}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{res} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{racine2}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{multlist}
\label{\detokenize{multlistv3.1:multlist}}\label{\detokenize{multlistv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multlist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{multlistv3.1:algorithm}}
\sphinxAtStartPar
Utils : A point by point list multiplier


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{a}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{b}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int/float list}
&
\sphinxAtStartPar
The list to multiply
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int / float list} : The computed point by point multiplication

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{multlistv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{transpose\_base}
\label{\detokenize{transpose_basev3.1:transpose-base}}\label{\detokenize{transpose_basev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{transpose_basev3.1:algorithm}}
\sphinxAtStartPar
A method to transpose an integer list to the corresponding key’s base index
=\textgreater{} The result will be a succession of transposed values from differents integers to differents base


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
the integer converted since ASCII list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list}
&
\sphinxAtStartPar
The full Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The crypted list as String list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{transpose_basev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else} \PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{inv\_transpose\_base}
\label{\detokenize{inv_transpose_basev3.1:inv-transpose-base}}\label{\detokenize{inv_transpose_basev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{inv_transpose_basev3.1:algorithm}}
\sphinxAtStartPar
The inverse method to decrypt a str list of base transposed values


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The crypted list as String list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The Base index list as key
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The full Base table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The decrypted list as integers

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{inv_transpose_basev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{!=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{==}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_procedure}
\label{\detokenize{crypt_procedurev3.1:crypt-procedure}}\label{\detokenize{crypt_procedurev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_procedurev3.1:algorithm}}
\sphinxAtStartPar
The crypter manager to orchestrate the crypting procedure.
It works from these steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We convert the given ascii string as integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the Base index list as key from the converted integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We build the second part of the key since the mirror of the Base index list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the cumulated weight of the integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We compute the point by point multiplication between cumulated weigth list and original integer list}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We transpose the multiplied list into the given specified Base from the key}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{We associate the crypted strin to the key as return}

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{string}
&
\sphinxAtStartPar
The string to crypt
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table recursively builded
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list tuple} : The couple crypted string and key as result. It permits to decrypt any message.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_procedurev3.1:source-code}}\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{int\PYGZus{}chaine} \PYG{o}{=} \PYG{n}{ascii\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{n}{base\PYGZus{}keyy}  \PYG{o}{=} \PYG{n}{base\PYGZus{}key}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{key}\PYG{o}{=}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{vec\PYGZus{}poid}   \PYG{o}{=} \PYG{n}{vec\PYGZus{}poids}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{multlist}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{vec\PYGZus{}poid}\PYG{p}{)}
\PYG{n}{crypt\PYGZus{}lst}  \PYG{o}{=} \PYG{n}{transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{base\PYGZus{}keyy}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(crypt\PYGZus{}lst)}
\PYG{k}{return}\PYG{p}{(}\PYG{n}{crypt\PYGZus{}lst}\PYG{p}{,}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

\newpage
\section{cyclik\_ascii}
\label{\detokenize{cyclik_asciiv3.1:cyclik-ascii}}\label{\detokenize{cyclik_asciiv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_asciiv3.1:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_asciiv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_lvl2}
\label{\detokenize{cyclik_ascii_lvl2v3.1:cyclik-ascii-lvl2}}\label{\detokenize{cyclik_ascii_lvl2v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}lvl2}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_lvl2v3.1:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into ponctuation signs.
Get a second cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_lvl2v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_lvl3}
\label{\detokenize{cyclik_ascii_lvl3v3.1:cyclik-ascii-lvl3}}\label{\detokenize{cyclik_ascii_lvl3v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}lvl3}\PYG{p}{(}\PYG{n}{current}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_lvl3v3.1:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into Upper letters from A to L.
Get a third cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_lvl3v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{sep}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{cyclik\_ascii\_mesquin}
\label{\detokenize{cyclik_ascii_mesquinv3.1:cyclik-ascii-mesquin}}\label{\detokenize{cyclik_ascii_mesquinv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{cyclik\PYGZus{}ascii\PYGZus{}mesquin}\PYG{p}{(}\PYG{n}{current}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{cyclik_ascii_mesquinv3.1:algorithm}}
\sphinxAtStartPar
Compute a cyclik ascii separators into Upper letters from M to Z.
Get a third cyclic ascii set modulo length


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{current}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The current poncuation separator
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The following separator from the defined ‘sep’ Set.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{cyclik_ascii_mesquinv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{mesquin}\PYG{p}{[}\PYG{n}{tmp}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{reverse}
\label{\detokenize{reversev3.1:reverse}}\label{\detokenize{reversev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{reverse}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{reversev3.1:algorithm}}
\sphinxAtStartPar
A function to reverse a string as argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameter}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{s}
&
\sphinxAtStartPar
\sphinxstyleemphasis{String}
&
\sphinxAtStartPar
The string to reverse
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The reversed string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{reversev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{split\_number}
\label{\detokenize{split_numberv3.1:split-number}}\label{\detokenize{split_numberv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split\PYGZus{}number}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{split_numberv3.1:algorithm}}
\sphinxAtStartPar
Integer splitter using the inverse Horner scheme and get it as a list of digits.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{num}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The integer to be splitted
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{list} : The splitted integer as list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{split_numberv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{num}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{num} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{n}{num}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{reverse}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{complement\_at}
\label{\detokenize{complement_atv3.1:complement-at}}\label{\detokenize{complement_atv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{complement\PYGZus{}at}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{complement_atv3.1:algorithm}}
\sphinxAtStartPar
Get the direct Base complemented value from the original x value.
The Base must be inferior or equal to 10.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{x}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The value to be complemented
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The current base
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The complemented value as an integer

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{complement_atv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{return} \PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{get\_value}
\label{\detokenize{get_valuev3.1:get-value}}\label{\detokenize{get_valuev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}value}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{get_valuev3.1:algorithm}}
\sphinxAtStartPar
A value getter to obtain an index from the original Base converted string value.
This method is working as the list ‘index’ method and allow us to get the raw full integer corresponding to the list of list value.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{x}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The value to search
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The full Base Table
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The index of the base
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int} : The real decimal value of the specified term in his own Base.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{get_valuev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{while}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{o}{!=}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{k}{return} \PYG{n}{ind}
\end{sphinxVerbatim}

\newpage
\section{complement\_at\_sup11}
\label{\detokenize{complement_at_sup11v3.1:complement-at-sup11}}\label{\detokenize{complement_at_sup11v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{complement\PYGZus{}at\PYGZus{}sup11}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{complement_at_sup11v3.1:algorithm}}
\sphinxAtStartPar
This function is used to compute the complement value from the original one in his own base.
I use a temporary variable to store the numeric value of the compement and restitute it in his own base.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{x}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
A string representation of my base converted value
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The full Base Table array
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base index of the current value
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The complmented value in his own Base.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{complement_at_sup11v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nb\PYGZus{}char}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{local\PYGZus{}max}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{nb\PYGZus{}char}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{local\PYGZus{}max}\PYG{o}{+}\PYG{o}{=}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{base}\PYG{o}{*}\PYG{o}{*}\PYG{n}{i}
\PYG{n}{num\PYGZus{}value}\PYG{o}{=}\PYG{n}{local\PYGZus{}max}\PYG{o}{\PYGZhy{}}\PYG{n}{get\PYGZus{}value}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{table}\PYG{p}{[}\PYG{n}{base}\PYG{p}{]}\PYG{p}{[}\PYG{n}{num\PYGZus{}value}\PYG{p}{]}
\end{sphinxVerbatim}

\newpage
\section{complement}
\label{\detokenize{complementv3.1:complement}}\label{\detokenize{complementv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{complement}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{complementv3.1:algorithm}}
\sphinxAtStartPar
The complement function is the full algorithm combining the complement\_at\_sup11 and complement\_at functions.
I specify the way to take between both of them using an if then else structure.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{x}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
A string representation of my base converted value
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The full Base Table array
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{base}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The base index of the current value
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The complmented value in his own Base.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{complementv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{final\PYGZus{}res}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{base}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{splitted}\PYG{o}{=}\PYG{n}{split\PYGZus{}number}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{splitted}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{splitted}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{complement\PYGZus{}at}\PYG{p}{(}\PYG{n}{splitted}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
                \PYG{n}{final\PYGZus{}res}\PYG{o}{*}\PYG{o}{=}\PYG{l+m+mi}{10}
                \PYG{n}{final\PYGZus{}res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{splitted}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{final\PYGZus{}res}
\PYG{k}{else}\PYG{p}{:}
        \PYG{n}{final\PYGZus{}res}\PYG{o}{=}\PYG{n}{complement\PYGZus{}at\PYGZus{}sup11}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{final\PYGZus{}res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final}
\label{\detokenize{crypt_finalv3.1:crypt-final}}\label{\detokenize{crypt_finalv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_finalv3.1:algorithm}}
\sphinxAtStartPar
The layout procedure to organise crypting results. The uodate consist to complement each of terms in his corresponding base.
It allow a superior level of crypting. I use the separators set as well.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted strin and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The crypted list as a string with correct separators

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_finalv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{n}{crypt}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{=}\PYG{n+nb}{tuple}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{tmp\PYGZus{}len}\PYG{o}{=}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{tmp\PYGZus{}len}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}len}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{tmp\PYGZus{}len}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{tmp\PYGZus{}len}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} injective crypt[i]}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{complement}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{crypt\_final\_long}
\label{\detokenize{crypt_final_longv3.1:crypt-final-long}}\label{\detokenize{crypt_final_longv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{crypt\PYGZus{}final\PYGZus{}long}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{crypt_final_longv3.1:algorithm}}
\sphinxAtStartPar
Chaining the final\sphinxhyphen{}level algorithm to get complex crypto\sphinxhyphen{}procedure


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{tuple}
&
\sphinxAtStartPar
\sphinxstyleemphasis{tuple}
&
\sphinxAtStartPar
List couple representing the crypted string and the associated key
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full second level crypted string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{crypt_final_longv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sept}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep} \PYG{o}{=}\PYG{n}{sept}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(res)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp}
\label{\detokenize{slurpv3.1:slurp}}\label{\detokenize{slurpv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurpv3.1:algorithm}}
\sphinxAtStartPar
This method allow us to rebuild a str list of crypted terms using separators set.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurpv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}tmp = \PYGZdq{}+tmp)}
        \PYG{k}{else} \PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}res = \PYGZdq{})}
                \PYG{c+c1}{\PYGZsh{} print(res)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp2}
\label{\detokenize{slurp2v3.1:slurp2}}\label{\detokenize{slurp2v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp2}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp2v3.1:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp method. It defined a second level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp2v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{?}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{@}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{slurp3}
\label{\detokenize{slurp3v3.1:slurp3}}\label{\detokenize{slurp3v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp3}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp3v3.1:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp2 method. It defined a third level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp3v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{mesquin}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{tmp}
\end{sphinxVerbatim}

\newpage
\section{slurp4}
\label{\detokenize{slurp4v3.1:slurp4}}\label{\detokenize{slurp4v3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slurp4}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{slurp4v3.1:algorithm}}
\sphinxAtStartPar
This method is similar of the slurp2 method. It defined a third level of crypting management.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string crypted message
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The list of crypted terms rebuilded from the raw string.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{slurp4v3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{chaine}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{elem}\PYG{o}{==}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{break}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{miam}
\label{\detokenize{miamv3.1:miam}}\label{\detokenize{miamv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{miam}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{miamv3.1:algorithm}}
\sphinxAtStartPar
Key builder from the half key as integer list. It rebuild the missing half with a mirror copy of the first one.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : The full key rebuilded from the half key

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{miamv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{this} \PYG{o+ow}{in} \PYG{n}{key}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}this = \PYGZdq{}+str(this))}
        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}tmp = \PYGZdq{}+str(tmp))}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{count}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{=}\PYG{l+m+mi}{1}
                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}tmp = \PYGZdq{}+str(tmp))}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{this}\PYG{p}{)}
                \PYG{n}{count}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{resolve}
\label{\detokenize{resolvev3.1:resolve}}\label{\detokenize{resolvev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{resolve}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{resolvev3.1:algorithm}}
\sphinxAtStartPar
This method compute the chained 2nd order equations to solve the numeric suit.
It permit us to get the ASCII values as a list.
To solve the system you have to instance the solver with the square root of term 0.
Once theorem zero done, you will apply the equation solver with square root of the 0\sphinxhyphen{}term as b,
a as 1 and c as \sphinxhyphen{}following term.
The algorithm sort the roots and take only positives ones.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The computed multiplied list to solve
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{int list} : A list containing solved terms.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{resolvev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{tmp2} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{tmp}\PYG{o}{=}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}y = \PYGZdq{}+str(tmp))}
        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}x = \PYGZdq{}+str(x))}
        \PYG{n}{tmp2} \PYG{o}{=} \PYG{n}{equa\PYGZus{}2\PYGZus{}nd}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{liste}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{x}\PYG{o}{=}\PYG{n}{tmp2}\PYG{o}{\PYGZhy{}}\PYG{n}{tmp}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{tmp2}
\PYG{c+c1}{\PYGZsh{} print(res)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{decrypt\_procedure}
\label{\detokenize{decrypt_procedurev3.1:decrypt-procedure}}\label{\detokenize{decrypt_procedurev3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{decrypt\PYGZus{}procedure}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{key}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{decrypt_procedurev3.1:algorithm}}
\sphinxAtStartPar
This method manage the decrypting procedure.
It is ruled by the following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Build the full key since the key argument

\item {} 
\sphinxAtStartPar
Split the string since separators via slurp method

\item {} 
\sphinxAtStartPar
Complement eah ch term in his own value

\item {} 
\sphinxAtStartPar
Apply the inv\_tranpose\_base method to get the uncrypted terms

\item {} 
\sphinxAtStartPar
Solve the cumulated multiplued weigth with the equation solver

\item {} 
\sphinxAtStartPar
Convert the int list as result to ASCII chain

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw crypted text as string
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{key}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int list}
&
\sphinxAtStartPar
The half key as int list
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{table}
&
\sphinxAtStartPar
\sphinxstyleemphasis{list of list}
&
\sphinxAtStartPar
The Base Table array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The uncrypted text.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{decrypt_procedurev3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{base}\PYG{o}{=}\PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{reverse}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{tmp} \PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{to\PYGZus{}find}\PYG{o}{=}\PYG{n}{slurp}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}injective inverse to\PYGZus{}find[i]}
        \PYG{n}{to\PYGZus{}find}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{complement}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{table}\PYG{p}{,}\PYG{n}{base}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{tmp\PYGZus{}liste}\PYG{o}{=}\PYG{n}{inv\PYGZus{}transpose\PYGZus{}base}\PYG{p}{(}\PYG{n}{to\PYGZus{}find}\PYG{p}{,}\PYG{n}{base}\PYG{p}{,}\PYG{n}{table}\PYG{p}{)}
\PYG{n}{int\PYGZus{}liste}\PYG{o}{=}\PYG{n}{resolve}\PYG{p}{(}\PYG{n}{tmp\PYGZus{}liste}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{int\PYGZus{}to\PYGZus{}ascii}\PYG{p}{(}\PYG{n}{int\PYGZus{}liste}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{split}
\label{\detokenize{splitv3.1:split}}\label{\detokenize{splitv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{split}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{splitv3.1:algorithm}}
\sphinxAtStartPar
Split the given string argument ‘chaine’ into slices from threshold size ‘seuil’.
Each of this slices are allowed into the cryptographic algorithm.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The full string to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{seuil}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
Define the threshold size of the slices
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str list} : The slices list as result

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{splitv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{div}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{o}{/}\PYG{n}{seuil}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{div}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
        \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}index = \PYGZdq{}+str(index)+\PYGZdq{} | seuil = \PYGZdq{}+str(seuil)+\PYGZdq{} | i = \PYGZdq{}+str(i))}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{index}\PYG{p}{,}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                \PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}j = \PYGZdq{}+str(j)+\PYGZdq{} | tmp = \PYGZdq{}+str(tmp))}
                \PYG{k}{if}\PYG{p}{(}\PYG{n}{j}\PYG{o}{==}\PYG{p}{(}\PYG{n}{index}\PYG{o}{+}\PYG{n}{seuil}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
                        \PYG{n}{index}\PYG{o}{=}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{index}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{index}\PYG{p}{:}\PYG{p}{]}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{tilps}
\label{\detokenize{tilpsv3.1:tilps}}\label{\detokenize{tilpsv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{tilps}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{tilpsv3.1:algorithm}}
\sphinxAtStartPar
The reverse method of the split function. From a given str list, we rebuild the full length string


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{chaine}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str list}
&
\sphinxAtStartPar
The String slices as a list
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The full striing rebuilded from the slices list

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{tilpsv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{chaine}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{chaine}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}

\newpage
\section{mesqui}
\label{\detokenize{mesquiv3.1:mesqui}}\label{\detokenize{mesquiv3.1::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mesqui}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{,}\PYG{n}{seuil}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{mesquiv3.1:algorithm}}
\sphinxAtStartPar
This method is used to create a wrong path of decrypting method.
Using a similar Separators terms, I define a ‘fake’ terms list wich have absolutely no meanings for the rest of the algorithm.
Using it as the last step of algorithm, it doesn’t allow any brute force attack to decrypt.
The threshold value ‘seuil’ will define the amount of distribution of fake separators.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{txt}
&
\sphinxAtStartPar
\sphinxstyleemphasis{str}
&
\sphinxAtStartPar
The raw string to treat
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{seuil}
&
\sphinxAtStartPar
\sphinxstyleemphasis{int}
&
\sphinxAtStartPar
The threshold variable to assign the ‘fake terms’ length
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{str} : The fully ‘fake splitted’ crypted string

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{mesquiv3.1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mesquin}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{sep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{txt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{seuil}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}
                \PYG{n}{sep}\PYG{o}{=}\PYG{n}{cyclik\PYGZus{}ascii\PYGZus{}mesquin}\PYG{p}{(}\PYG{n}{sep}\PYG{p}{,}\PYG{n}{int\PYGZus{}chaine}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Aternative Algorithm v1}
\label{\detokenize{alternativev1:raptor-cryptographic-aternative-algorithm-v1}}\label{\detokenize{alternativev1::doc}}
\newpage
\section{Description of Crypter}
\label{\detokenize{Description of AltCrypterv1:description-of-crypter}}\label{\detokenize{Description of AltCrypterv1::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Main Raptor Cryptographic Alternative Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of AltCrypterv1:algorithm}}
\sphinxAtStartPar
This is the main Raptor Cryptographic Alternative algorithm.
During my researches, I have thought about an other version of the algorithm optimised for the long data stream as string.
The first algorithm use exponentional integer values list instead of this one wich allow to treat bigger slices using a divider.
Each term will be divide during the algorithm.
This algorithm is rules by following steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting inputs}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Converting ASCII} to Integers values to get a numeric list

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dividing chain} : eachterm is divided by the next one

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiplying} each i\_term to the i+1\_term modulo the i+2\_term to get the key modulo 26. It means key(i)=((data(i)*data(i+1)) modulo data(i+2)) modulo 26

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiplying} each term of the crypt list with 10000 to get integers values from float.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Key padding} to confirm key appending the two first elements of the key at the end and the top one numric list at the end

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Transposing} to the associated key index Base the full data list

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Adding separators} from the sep Set to split each term from another

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of AltCrypterv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{base\PYGZus{}opt} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{vir}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Construction de la table des bases}

\PYG{n}{table}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Algorithme de cryptage}

\PYG{n}{txt}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Entrez un texte}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{l}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{l}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{first}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{key}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}               \PYG{c+c1}{\PYGZsh{} Finir la chaine de texte par trois caractères \PYGZdq{}usuels\PYGZdq{}, par exemple \PYGZdq{}...\PYGZdq{}}
        \PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Eventuellement ameliorer la clé en la complementant a 36 sur [10,36]}
        \PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{26}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{}key padding}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}

\PYG{n}{crypt}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} rajouter des operations de listes reversibles}

\PYG{n}{string}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{string}\PYG{o}{+}\PYG{o}{=}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{n}{string}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{]}

\PYG{n}{str\PYGZus{}key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}key}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{str\PYGZus{}key}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{str\PYGZus{}key}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{})}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{string}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} print(\PYGZdq{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZdq{})}
\PYG{n}{quit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}Crypter}
\label{\detokenize{DescriptionofAltDecrypterv1:description-of-de-crypter}}\label{\detokenize{DescriptionofAltDecrypterv1::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Main Raptor Cryptographic Alternative Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofAltDecrypterv1:algorithm}}
\sphinxAtStartPar
To decrypt the obtained string sequence from the Crypter, you have to follow these steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rebuild} original term list from the string using the sep Set

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Transpose} each term in his corresponding Base from the key to get integers values.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dividing} each of term by 10000 to restitute float values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The zero step of decrypting} is the multiplication of the first term of the list with the first value of the begining Ascii converted list (appending it to the key to make it confidential)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Restitute} each i\_term multiplying with i\sphinxhyphen{}1\_term

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rounding and restitute} via conversion the origial ASCII chain.

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofAltDecrypterv1:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{base\PYGZus{}opt} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{vir}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Construction de la table des bases}

\PYG{n}{table}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{string}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{chaine cryptée : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{str\PYGZus{}key}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clé : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{key}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{str\PYGZus{}key}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{item}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}


\PYG{n}{rez}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{first} \PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{key}\PYG{o}{=} \PYG{n}{key}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{string}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{sep}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{item}
                \PYG{c+c1}{\PYGZsh{} print(tmp)}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{rez}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{key}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{firstt}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{rez}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Algorithme de décryptage}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{10000}

\PYG{n}{rezz}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{rezz}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{first}\PYG{o}{*}\PYG{n}{rez}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rezz}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{rezz}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{final}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rezz}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{final}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{rezz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{txt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{txt}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{final}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{txt}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{final}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Raptor Cryptographic Aternative Algorithm v2}
\label{\detokenize{alternativev2:raptor-cryptographic-aternative-algorithm-v2}}\label{\detokenize{alternativev2::doc}}
\newpage
\section{Description of Crypter}
\label{\detokenize{Description of AltCrypterv2:description-of-crypter}}\label{\detokenize{Description of AltCrypterv2::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Main Raptor Cryptographic Alternative Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{Description of AltCrypterv2:algorithm}}
\sphinxAtStartPar
This is the main Raptor Cryptographic Alternative algorithm v2.
The difference between both versions is the type of the numbers list. The second version is using
a representation of float crypted preserving the full precision of the values.
This one is stable on his definition’s domain and could be considered as the first one as ‘fast crypting algorithm’.
There are differents ways to use :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cybersecurity of business and organization} (Hospitals, banks, etc)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Crypting data stream} on the web

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Crypting authentification} informations

\end{itemize}

\sphinxAtStartPar
This algorithm is ruled by the followings steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Define two differents sets} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The sep Set} representing terms separators

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The vir Set} reprseneting the comma in float values

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Getting raw string} as input

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Converting ASCII values} to their decimal correspondence

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dividing each i+1\_term of the list by the i\_term} of the list

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building key} from the given formula : key(i)=((l(i)*l(i+1) modulo l(i+2)) modulo 26)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiplying each term by 10000}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Building the mirror key} from the original one

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Compute each fraction} division float value. Each fraction is defined by res(i)/key(i+1). Each part of the value is represented into a single integer value

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Multiplying each float res by 10} to get larger values (useful to Base Table converter)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Convert} into key\sphinxhyphen{}indexed Base Table values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Defining commas and separators} from the vir and sep Sets

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Return the full crypted string}

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{Description of AltCrypterv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{base\PYGZus{}opt} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}
\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{vir}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{table}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Algorithme de cryptage}

\PYG{n}{txt}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Entrez un texte}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{l}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{l}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{first}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{key}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}               \PYG{c+c1}{\PYGZsh{} Finir la chaine de texte par trois caractères \PYGZdq{}usuels\PYGZdq{}, par exemple \PYGZdq{}...\PYGZdq{}}
        \PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Eventuellement ameliorer la clé en la complementant a 36 sur [10,36]}
        \PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{26}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{10000}\PYG{p}{)}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}      \PYG{c+c1}{\PYGZsh{}key padding}
\PYG{n}{key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{tmp}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{Float\PYGZus{}res}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Mirror\PYGZus{}key}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{Mirror\PYGZus{}key}\PYG{o}{=}\PYG{n}{mirror}\PYG{p}{(}\PYG{n}{key}\PYG{p}{)}
\PYG{n}{Mirror\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Compute each fraction division float value. Each fraction is defined by res(i)/key(i+1)}
\PYG{c+c1}{\PYGZsh{} Each part of the value is represented into a single integer value}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{p}{(}\PYG{n}{key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{Float\PYGZus{}res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{Float\PYGZus{}res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{tmp}\PYG{o}{=}\PYG{l+m+mf}{0.0}

\PYG{c+c1}{\PYGZsh{}Multiplying each float res by 10 to get larger values (useful to Base Table converter)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Float\PYGZus{}res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Float\PYGZus{}res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{o}{=}\PYG{l+m+mi}{10}

\PYG{c+c1}{\PYGZsh{}Convert into key\PYGZhy{}indexed Base Table values}
\PYG{n}{crypt}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Float\PYGZus{}res}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{crypt}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{n}{Float\PYGZus{}res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} rajouter des operations de listes reversibles}

\PYG{n}{string}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{c+c1}{\PYGZsh{} Defining commas and separators from the vir and sep Sets}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{crypt}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{string}\PYG{o}{+}\PYG{o}{=}\PYG{n}{crypt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{ind}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{string}\PYG{o}{+}\PYG{o}{=}\PYG{n}{vir}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{string}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{]}
        \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}

\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{str\PYGZus{}key}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{str\PYGZus{}key}\PYG{o}{+}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{str\PYGZus{}key}\PYG{o}{+}\PYG{o}{=}\PYG{n}{sep}\PYG{p}{[}\PYG{n}{r}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{p}{]}

\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{key : }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{str\PYGZus{}key}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Return the full crypted string}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{string = }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{string}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{quit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{Description of De\sphinxhyphen{}Crypter}
\label{\detokenize{DescriptionofAltDecrypterv2:description-of-de-crypter}}\label{\detokenize{DescriptionofAltDecrypterv2::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Main Raptor Cryptographic Alternative Algorithm}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{DescriptionofAltDecrypterv2:algorithm}}
\sphinxAtStartPar
To decrypt the obtained string sequence from the Crypter, you have to follow these steps :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rebuild the terms list} from the given string using sep and vir Sets

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Convert crypted value} to their integer index

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Devide each of value by 10} to get the smaller origianl values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rebuild float values} from the integer couples values

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Round multiplication} of float value and Mirror key value to rebuild terms

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Divide each computed values} from multiplication of i\_term fo the float list with the last computed term by 10000 to get origianls terms

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Round and convert to ASCII} values to get the original string

\end{itemize}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{DescriptionofAltDecrypterv2:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{base\PYGZus{}opt} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{import} \PYG{n+nn}{random} \PYG{k+kn}{as} \PYG{n+nn}{r}

\PYG{n}{sep}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZam{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{vir}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{G}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{I}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{J}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{K}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{O}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{T}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{table}\PYG{o}{=}\PYG{n}{table}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{string}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Chaine Cryptée : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{str\PYGZus{}key}\PYG{o}{=}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Clé : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{Mirror\PYGZus{}key}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{str\PYGZus{}key}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{sep} \PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{item}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{Mirror\PYGZus{}key}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}

\PYG{n}{rez}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ind}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{first}\PYG{o}{=}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Mirror\PYGZus{}key}\PYG{o}{=}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Rebuild the terms list from the given string using sep and vir Sets}
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{string}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{sep} \PYG{o+ow}{and} \PYG{o+ow}{not} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{vir}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{+}\PYG{o}{=}\PYG{n}{item}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{c+c1}{\PYGZsh{} Convert crypted value to their integer index}
                \PYG{n}{rez}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{table}\PYG{p}{[}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{n}{ind}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{tmp}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
                \PYG{n}{ind}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{firstt}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{rez}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Devide each of value by 10 to get the smaller origianl values}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{n}{Float\PYGZus{}rez}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Rebuild float values from the integer couples values}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{Float\PYGZus{}rez}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{tmp}\PYG{o}{+}\PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{/}\PYG{l+m+mi}{1000}\PYG{p}{)}
                \PYG{n}{tmp}\PYG{o}{=}\PYG{l+m+mf}{0.0}

\PYG{c+c1}{\PYGZsh{} Algorithme de décryptage}

\PYG{c+c1}{\PYGZsh{} Round multiplication of float value and Mirror key value to rebuild terms}
\PYG{n}{rez}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Float\PYGZus{}rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rez}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{Float\PYGZus{}rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Mirror\PYGZus{}key}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{rezz}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{rezz}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{first}\PYG{o}{*}\PYG{n}{rez}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10000}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Divide each computed values from multiplication of i\PYGZus{}term fo the float list with the last computed term by 10000 to get origianls terms}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rezz}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rez}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{rezz}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10000}\PYG{p}{)}

\PYG{n}{final}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} Round and convert to ASCII values to get the original string}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{rezz}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{final}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{rezz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{txt}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{txt}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{n}{first}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{final}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{txt}\PYG{o}{+}\PYG{o}{=}\PYG{n}{final}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{txt}\PYG{p}{)}
\end{sphinxVerbatim}

\newpage
\section{mirror}
\label{\detokenize{mirror:mirror}}\label{\detokenize{mirror::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{mirror}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}
\end{sphinxVerbatim}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Algorithm}}
\label{\detokenize{mirror:algorithm}}
\sphinxAtStartPar
The mirror function build a mirror list from the given one.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline

\sphinxAtStartPar
\sphinxstylestrong{Parameters}
&
\sphinxAtStartPar
\sphinxstylestrong{Type}
&
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\hline
\sphinxAtStartPar
\sphinxstylestrong{liste}
&
\sphinxAtStartPar
list
&
\sphinxAtStartPar
The list to be treat
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
list : The mirror list from the given parameter.

\end{description}\end{quote}


\bigskip\hrule\bigskip



\subsection{\sphinxstylestrong{Source Code}}
\label{\detokenize{mirror:source-code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{=}\PYG{n}{liste}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{liste}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{return} \PYG{n}{res}
\end{sphinxVerbatim}


\chapter{Math Proof}
\label{\detokenize{Math_proof:math-proof}}\label{\detokenize{Math_proof::doc}}



\section{Crypting Protocol}

\begin{flushleft}
We will crypt a simple message containing the word 'salut'.

In a first step we have to compute the weight list of the differents caracters (meaning an approximation of the ASCII code used in the computer code algorithm).
\end{flushleft}

\subsection{Weigth List}
\begin{flushleft}
Giving 0 to 'a' to 26 to 'z', we have : \textit{18.0.11.20.19} as the weigth list of the string
\end{flushleft}

\subsection{Cumulated weigth list}

\begin{flushleft}
Once done, we have to compute the cumulated weigth list.
I mean, the list application can be considered as a suit defined by : 
\end{flushleft}

\begin{center}
$u_{n}$ a suit from N to N with the length $n$ $ \in $ N \quad $ \vert $ \quad $u_{i}$=$u_{i-2}$+$u_{i-1}$
\end{center}

In our case, the computed list is \textit{18.18.29.49.68}
We call it $v_{i}$
\subsection{Key Computing}

\begin{flushleft}
At this moment we have to compute the public key $k_{i}$ of the algorithm defined via modulo since the formula :
\end{flushleft}

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
k_{i}=[u_{i}.u_{n-i} \quad mod \quad 26 ] + 10  \hspace*{1cm} if \quad \exists u_{i} , u_{n-i}  \\
\left. u_{j}  \; \hspace*{5cm} if \quad !\exists u_{j}, j = n/2 + 1
\right.\end{array}\,.
\right.\end{equation}

With our example, it gives :

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
k_{0}=[18.19 \quad  mod \quad  26] + 10 = 14 \\
k_{1}=[20.0 \quad  mod \quad  26] + 10 = 10 \\
k_{2}=[11 \quad  mod \quad  26] + 10 = 11 \\
\end{array}\right.\,.
\end{equation}

We build the full Length key $\xi$  \ using the formula :

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
\xi_{i} = k_{i} \hspace*{1cm} if \quad i <= n/2 + 1 \\ 
\xi_{i} = k_{n-i} \hspace*{1cm} if \quad i > n/2 + 1 \\ 
\end{array}\right.\,.
\end{equation}

\newpage

\subsection{Crypting Process}
\begin{flushleft}
The crypting process is ruled by a pseudo-convolution with the given symbol $*$ meaning a point by point multiplication. 
This newer suit is ruled by $v_{i}$ and $u_{i}$
We call it $w_{i}$ defined by : $v_{i}$ $*$ $u_{i}$

In our example, it gives :
\end{flushleft}

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
w_{0}=v_{0}.u_{0}=324 \\
w_{1}=v_{1}.u_{1}=0 \\
w_{2}=v_{2}.u_{2}=319 \\
w_{3}=v_{3}.u_{3}=980 \\
w_{4}=v_{5}.u_{4}=1292 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
We obtain the suit $w$=\textit{324.0.319.980.1292}
\end{flushleft}

\subsection{Encryption}
\begin{flushleft}
At the end we use the Encryption into differents numeric bases to hide the crypting process.

The Base indexes are defined by the key $ \xi $ \\
The list to encrypt is defined by $w$ \\
The Encryption process will be caled $ \Xi $ \\
Defined by : 
\begin{equation}
\Xi_{i}=(w_{i})_{\xi_{i}}
\end{equation}
\end{flushleft}

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
\Xi_{0} = (w_{0})_{\xi_{0}}=(324)_{14}=192 \\
\Xi_{1} = (w_{1})_{\xi_{1}}=(0)_{10}=0 \\
\Xi_{2} = (w_{2})_{\xi_{2}}=(319)_{11}=270 \\
\Xi_{3} = (w_{3})_{\xi_{3}}=(980)_{10}=980 \\
\Xi_{4} = (w_{4})_{\xi_{4}}=(1292)_{14}=684 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
The Encrypted suit is $ \Xi $ \ = \textit{192.0.270.980.684}

Its associate key is $ \xi $  \ = \textit{14.10.11.10.14}
\end{flushleft}

\newpage

\section{Decrypting Protocol}

\subsection{Initialisation}


\begin{flushleft}
In this demonstration, we will use a Encrypted list using the Raptor cryptographic algorithm.
The terms list is given by :
\end{flushleft}

\begin{center}
!018kh"05a3c\#8064\$12vj\%2gai\&0605a(67500)0ba30*277a4+25376,2a5db-5813\.36u7!146367"27706\#1j68c
\end{center}

\begin{flushleft}
The associated key is given as a public key : 
\end{flushleft}

\begin{center}
2116103428141013
\end{center}

\begin{flushleft}
We consider in a first time differents type of caracters set used in the crypting and Encrypting processes.
\end{flushleft}

\begin{center}
\S = [!,",\#,\$,\%,\&,(,),*,+,-,\.]
\end{center}

Using this informations, we could get a first Terms list to treat called $ \Xi $.

\begin{center}
\textit{018kh.05a3c.8064.12vj.2gai.0605a.67500.0ba30.277a4.25376.2a5db.5813.36u7.146367.27706.1j68c}
\end{center}


\begin{flushleft}
  A list with length 16 is highlighting
We will use the Set X  = [a-z] $ \cup $  \ [0-9]

With $ \chi $\ the length of the Terms list.

Here $ \chi $ \ = 16, we could observ than length of key $ \rho  \quad  \vert \quad  \rho  = \chi . $

$ \Xi_{i} $ will represent the respectives terms of the list.

We start the decrypting process by exctracting the key's Bases index from the $c_{n}$ number suit contained in key.
with $ c_{i} $, $ \forall $ i $ \in $ [0,$ \rho $ \ ], $ c_{i} $ $\leq $ 9

\end{flushleft}

\begin{center}
We obtain : $\xi $ = \textit{21.16.10.34.28.14.10.13}
\end{center}
\newpage
\subsection{Successive Base Transpositions - Step 1}

\begin{flushleft}
  Highlighted $\xi_{j}$ , Bases index are consistent with the Terms of the suit $\Xi$

Thereby, with the Correspondance between $ \xi_{0}$ and $\Xi_{0}$ , we obtain the following chained system resolution.
\end{flushleft}

\subsection{$\Xi_{0}$ = 018kh, $\xi_{0}$ = 21}
By drawing up the 21 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
0=0 \\
1=1 \\
8=8 \\
k=20 \\
h=17 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 21 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(018kh)_{21}=(0.21^{4}+1.21^{3}+8.21^{2}+20.21+17)_{10}=13226
\end{equation}

\subsection{$\Xi_{1}$ = 05a3c, $\xi_{1}$ = 16}
By drawing up the 16 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
0=0 \\
5=5 \\
a=10 \\
3=3 \\
c=12 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 16 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(05a3c)_{16}=(5.16^{3}+10.16^{2}+3.16+12)_{10}=23100
\end{equation}

\subsection{$\Xi_{2}$ = 8064, $\xi_{2}$ = 10}
The specified base index $\xi_{2}$ = 10, so any conversion is superfluous.


\subsection{$\Xi_{3}$ = 12vj, $\xi_{3}$ = 34}
By drawing up the 34 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
1=1 \\
2=2 \\
v=31 \\
j=19 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 34 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(12vj)_{34}=(1.34^{3}+2.34^{2}+31.34+19)_{10}=42689
\end{equation}

\subsection{$\Xi_{4}$ = 2gai, $\xi_{4}$ = 28}
By drawing up the 28 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
2=2 \\
g=16 \\
a=10 \\
i=18 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 28 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(2gai)_{28}=(2.28^{3}+16.28^{2}+10.28+18)_{10}=56746
\end{equation}

\subsection{$\Xi_{5}$ = 0605a, $\xi_{5}$ = 14}
By drawing up the 14 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
0=0 \\
6=6 \\
5=5 \\
a=10 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 14 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(0605a)_{14}=(6.14^{3}+5.14+10)_{10}=16544
\end{equation}

\subsection{$\Xi_{6}$ = 67500, $\xi_{6}$ = 10}
The specified base index $\xi_{6}$ = 10, so any conversion is superfluous.


\subsection{$\Xi_{7}$ = 0ba30, $\xi_{7}$ = 13}
By drawing up the 13 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
b=11 \\
a=10 \\
3=3 \\
0=0 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 13 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(0ba30)_{13}=(11.13^{3}+10.13^{2}+3.13+13)_{10}=25886
\end{equation}

The Base transposition done, we could reverse the key to obtain the rest of the list.
\subsection{Key build}
\begin{flushleft}
We can use the following definition :

$\rho$ is the length of the key $\xi$ since Initialisation Section.

We go to compare the $\rho$ length of $\xi$ with $\chi$ the length of $\Xi$.We have $\chi$=2.$\rho$

We will use the following terms : 

\begin{itemize}
  \item $\tilde{\xi}$ : the mirror of $\xi$
  
  \item $\tilde{\xi}_{/n}$ : the mirror of $\xi$ bereft of $\xi_{n}$
  
  \item $\mathring{\xi}$ : the rebuilded key  
  
  \item $\frown$ : the concatenation operator
\end{itemize}
\end{flushleft}

\begin{flushleft}
To rebuild the missing half key, we go to reverse $\xi$ with the following syntax   
\end{flushleft}

\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
\mathring{\xi} = \xi^\frown  \tilde{\xi} \hspace*{4cm} if \quad \chi \quad mod \quad 2 = 0\\
\mathring{\xi} = \xi^\frown  \tilde{\xi}_{/n} \hspace*{3.7cm} if \quad \chi \quad mod \quad 2 = 1
\end{array}\right.\,.
\end{equation}

\subsection{Successive Base Transpositions - Step 2}

Once the full key rebuilded from $\xi$, we could transpose again the rest of the list as step 1.

\subsection{$\Xi_{8}$ = 277a4, $\xi_{8}$ = 13}
By drawing up the 13 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
2=2 \\
4=4 \\
7=7 \\
a=10 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 13 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(277a4)_{13}=(2.13{4}+7.13^{3}+7.13^{2}+10.13+4)_{10}=73818
\end{equation}

\subsection{$\Xi_{9}$ = 25376, $\xi_{9}$ = 10}
The specified base index $\xi_{9}$ = 10, so any conversion is superfluous.

\subsection{$\Xi_{10}$ = 2a5db, $\xi_{10}$ = 14}
By drawing up the 14 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
2=2 \\
5=5 \\
a=10 \\
b=11 \\
d=13 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 14 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(2a5db)_{14}=(2.14{4}+10.14^{3}+5.14^{2}+13.14+11)_{10}=105 445
\end{equation}

\subsection{$\Xi_{11}$ = 5813, $\xi_{11}$ = 28}
By drawing up the 28 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
1=1 \\
3=3 \\
5=5 \\
8=8 \\

\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 28 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(5813)_{28}=(5.28^{3}+8.28^{2}+1.28+3)_{10}=116 063
\end{equation}

\subsection{$\Xi_{12}$ = 36u7, $\xi_{12}$ = 34}
By drawing up the 34 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
3=3 \\
6=6 \\
7=7 \\
u=30 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 34 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(36u7)_{34}=(3.34^{3}+6.34^{2}+30.34+7)_{10}=125 875
\end{equation}

\subsection{$\Xi_{13}$ = 146367, $\xi_{13}$ = 10}
The specified base index $\xi_{13}$ = 10, so any conversion is superfluous.

\subsection{$\Xi_{14}$ = 27706, $\xi_{14}$ = 16}

\begin{flushleft}
  Or by performing a Base transposition since the 16 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(27706)_{16}=(2.16{4}+7.16^{3}+7.16^{2}+6)_{10}=161542
\end{equation}

\subsection{$\Xi_{15}$ = 1j68c, $\xi_{15}$ = 21}
By drawing up the 21 Base Table, we find :
\begin{equation}
\centering
\left\{\begin{array}{@{}l@{}}
1=1 \\
6=6 \\
8=8 \\
c=12 \\
j=19 \\
\end{array}\right.\,.
\end{equation}

\begin{flushleft}
  Or by performing a Base transposition since the 21 Base Table, we obtain :
\end{flushleft}
\begin{equation}
(1j68c)_{21}=(1.21{4}+19.21^{3}+6.21^{2}+8.21+12)_{10}=373266
\end{equation}

\begin{center}
  We finnaly obtain the following numeric suit :
  
\textit{13226.23100.42689.56746.16544.67500.25886.73818.25376.105445.116063.125875.161542.373266}
\end{center}

\subsection{Chain Polynom Resolution}

To continue the decrypting process, we know the suit increasing by recurrence.
We can resolve the polynom using logic, we call it $Ch$.

\begin{center}
  $Ch_{n}$ = $y^{2}$+($y'^{2}$+($y''^{2}$+...+$y^{(n)2}$)).y + c =0
\end{center}
The recursive injection of a polynome is resolvable uniquely using positive real roots.

With this definition, we will not keep cases with $\triangle \leq 0 $ 

In the last section of the demonstration, we will use the Chain Polynoms resolution algorithm defined by :
\begin{itemize}
  \item Solve $ y^{2}+b.y-\Xi_{i}=0$
  \item $x=(root > 0) - b$
  \item $b = root$
  \item Add x to the solved list R.
\end{itemize}
\newpage
We gonna initialize the procedure with :
\begin{itemize}
  \item \begin{flushleft}
    $ y^{2}=\Xi_{0} \iff y=\sqrt{13226}=115$
    
  $R_{0}=115$
  \end{flushleft}
  \item \begin{flushleft}
  $ y^{2}-115.y-23100=0$
  
  $x=220-115=105$
  
  $R_{1}=105$
\end{flushleft}
  \item \begin{flushleft}
  $ y^{2}-220.y-8064=0$
  
  $R_{2}=252-220=32$
\end{flushleft}
\item \begin{flushleft}
$ y^{2}-252.y-42688=0$

$R_{3}=368-252=116$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-368.y-56745=0$
  
  $R_{4}=485-368=117$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-485.y-16544=0$
  
  $R_{5}=517-485=32$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-517.y-67500=0$
  
  $R_{6}=625-517=108$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-625.y-25896=0$
  
  $R_{7}=664-625=39$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-664.y-73817=0$
  
  $R_{8}=761-664=97$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-761.y-25376=0$
  
  $R_{9}=793-761=32$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-793.y-105444=0$
  
  $R_{10}=909-793=116$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-909.y-116622=0$
  
  $R_{11}=1023-909=114$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-1023.y-125874=0$
  
  $R_{12}=1134-1023=111$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-1134.y-146367=0$
  
  $R_{13}=1251-1134=117$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-1251.y-161542=0$
  
  $R_{14}=1369-1251=118$
\end{flushleft}
\item \begin{flushleft}
  $ y^{2}-1369.y-373266=0$
  
  $R_{15}=1602-1369=118$
\end{flushleft}
\end{itemize}

\subsection{Conclusion}

\begin{flushleft}
  we can conclude using a simple ASCII table and get letters from the obtained numeric suit.

R=\{115,105,32,116,117,32,108,39,97,92,116,114,11,117,118,233\}

$ASCII_{R}$=\{s,i, ,t,u, ,l,',a, ,t,r,o,u,v,é \}
\end{flushleft}

\begin{center}
  We can get the final decrypted string : "si tu l'a trouvé"
\end{center}




\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}